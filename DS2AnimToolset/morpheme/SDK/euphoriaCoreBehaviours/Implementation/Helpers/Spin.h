#pragma once

/*
* Copyright (c) 2011 NaturalMotion Ltd. All rights reserved.
*
* Not to be copied, adapted, modified, used, distributed, sold,
* licensed or commercially exploited in any manner without the
* written consent of NaturalMotion.
*
* All non public elements of this software are the confidential
* information of NaturalMotion and may not be disclosed to any
* person nor used for any purpose not expressly approved by
* NaturalMotion in writing.
*
*/

#ifndef NM_SPIN_H
#define NM_SPIN_H

#include "AutoGenerated/NetworkForceInclude.h"
#include "AutoGenerated/Types/RotationRequest.h"

#ifndef NM_BEHAVIOUR_LIB_NAMESPACE
  #error behaviour library namespace undefined
#endif
#define SCALING_SOURCE owner->data->dimensionalScaling
#include "euphoria/erDimensionalScalingHelpers.h"
namespace NM_BEHAVIOUR_LIB_NAMESPACE
{
//----------------------------------------------------------------------------------------------------------------------
// Calculate torque required to get to requested rotation within requested time
template<typename OwnerType, typename InType>
NMP::Vector3 getRequiredNormalisedTorque(
  NMP::Vector3& torque,
  OwnerType& owner,
  InType& in,
  const ArmAndLegLimbSharedState& limbState,
  float timeStep,
  float maxNormalTorque,
  MR::InstanceDebugInterface* MR_OUTPUT_DEBUG_ARG(pDebugDrawInst))
{
  const ER::LimbTransform& root = limbState.m_rootTM;
  NMP::Vector3 targetRootAngularVel = in->getRotationRequest().rotation * in->getRotationRequest().imminence;
  MR_DEBUG_DRAW_VECTOR(pDebugDrawInst, MR::VT_AngularVelocity, limbState.m_basePosition, targetRootAngularVel,
    NMP::Colour::RED);
  NMP::Vector3 spineAngVel = owner->owner->data->spineLimbSharedStates[0].m_dynamicState.getAngularVelocity();
  MR_DEBUG_DRAW_VECTOR(pDebugDrawInst, MR::VT_AngularVelocity, limbState.m_basePosition, spineAngVel,
    NMP::Colour::TURQUOISE);
  // This value below is close to correct, so shouldn't be used to adjust the spin characteristics
  float bodyInertia = SCALE_INERTIA(12.0f);

  NMP::Vector3 requiredTorque = -(targetRootAngularVel - spineAngVel) * bodyInertia * in->getRotationRequest().imminence;
  // 0.3 below is 4/12 which is the coefficient for inertia for a rod spinning around its centre, an approximation of a rotating arm
  // e.g. if inertia is 0.3 * radius^2 * mass then scaledArmMass is 0.1*mass.
  float scaledLimbMass = 0.3f * limbState.m_dynamicState.mass;
  NMP::Vector3 targetTotalTorque = requiredTorque + torque;

  // Convert to local space, scale by local space weights, convert back to world space
  float spinWeightLateral = in->getSpinParamsImportance() ? in->getSpinParams().spinWeightLateral : 1.0f;
  float spinWeightUp      = in->getSpinParamsImportance() ? in->getSpinParams().spinWeightUp      : 0.5f;
  float spinWeightForward = in->getSpinParamsImportance() ? in->getSpinParams().spinWeightForward : 0.5f;
  NMP::Vector3 adjustedTotalTorque(0, 0, 0);
  adjustedTotalTorque += root.rightDirection() * root.rightDirection().dot(targetTotalTorque) * spinWeightLateral;
  adjustedTotalTorque += root.upDirection() * root.upDirection().dot(targetTotalTorque) * spinWeightUp;
  adjustedTotalTorque += root.frontDirection() * root.frontDirection().dot(targetTotalTorque) * spinWeightForward;
  targetTotalTorque = adjustedTotalTorque;

  MR_DEBUG_DRAW_VECTOR(pDebugDrawInst, MR::VT_AngularVelocity, limbState.m_basePosition, torque / (bodyInertia * in->getRotationRequest().imminence),
    NMP::Colour::YELLOW);

  // This smoothing is akin to the strength of the windmill, this is the parameter to tweak
  float smoothTime = 1.0f / SCALE_FREQUENCY(12.0f); // Default value
  if (in->getSpinAmount() > 0.0f)
    smoothTime = 1.0f / in->getSpinAmount();
  NMP::smoothExponential(torque, timeStep, targetTotalTorque, smoothTime);
  // Damp the energy of the system, this (and clamping) stops the speeds from going higher and higher
  float spinDamping = SCALE_DAMPING(1.0f);
  torque /= 1.0f + spinDamping * timeStep;
  // Stop torque from getting higher than the limb is able to achieve
  torque.clampMagnitude(maxNormalTorque * scaledLimbMass);

  // We return unsmoothed torque here, as the smoothing represents what is done in the soft joints, so we don't want to smooth twice
  return targetTotalTorque / scaledLimbMass;
}

//----------------------------------------------------------------------------------------------------------------------
// Convert torque to a radius, stiffness and an angular speed:
template<typename OwnerType>
void scaleParametersProportionallyFromTorque(
  float& angSpeed, float& radius, float& stiffness, float& normalisedTorque, OwnerType& owner)
{
  // the maximums are what is passed in. Clamp to avoid div by zero
  float maxAngSpeed = NMP::maximum(angSpeed, SCALE_ANGVEL(0.01f));;
  float maxRadius = radius;
  float maxStiffness = NMP::maximum(stiffness, SCALE_STIFFNESS(0.01f));

  // This is the formula: radius*radius * angSpeed * stiffness = normalisedTorque;
  // But we need angSpeed and stiffness to coincide, so angspeed never gets too fast for stiffness
  // therefore angspeed*stiffness must hit a max at maxangspeed * maxstiffness
  float maxAngSpeedTimesStiffness = maxAngSpeed * maxStiffness;
  // and equivalently for radius*radius
  float maxRadiusSqr = maxRadius * maxRadius;

  // Now it should be clear that we need to square root normalised torque in order to get a speedTimesStrength and a radius*radius
  // here are the formulas:
  float angSpeedTimesStiffness = NMP::fastSqrt(normalisedTorque * maxAngSpeedTimesStiffness / maxRadiusSqr);
  float radiusSqr              = NMP::fastSqrt(normalisedTorque * maxRadiusSqr / maxAngSpeedTimesStiffness);

  // so set the clamped radius
  radius = NMP::minimum(sqrtf(radiusSqr), maxRadius);

  // and get the clamped target angular velocity and strength
  // How do we do this? Well, same technique again, to give the max strength when at the max angular velocity
  angSpeed  = NMP::fastSqrt(angSpeedTimesStiffness * maxAngSpeed  / maxStiffness);
  stiffness = NMP::fastSqrt(angSpeedTimesStiffness * maxStiffness / maxAngSpeed);

  // now clamp. Since they have been scaled in proportion they should both clamp in the same circumstances
  angSpeed  = NMP::minimum(angSpeed, maxAngSpeed);
  stiffness = NMP::minimum(stiffness, maxStiffness);

  // 3. Convert the strength into a stiffness and importance:
  // use importance up until normalStiffness, as done elsewhere, gives a nice balance between reliquishing control and taking full control
  if (stiffness < owner->data->normalStiffness)
  {
    // This sqr accounts for the fact that importance blends the strength, which is the square of the stiffness
    float radiusScale = NMP::sqr(stiffness / owner->data->normalStiffness);
    stiffness = owner->data->normalStiffness;

    // artificially reduce radius to avoid wobble problems, there should be a small reduction anyway due to importance being kept high
    radius *= NMP::maximum(0.0f, (2.0f * radiusScale) - 1.0f);
  }
}

}

#endif
