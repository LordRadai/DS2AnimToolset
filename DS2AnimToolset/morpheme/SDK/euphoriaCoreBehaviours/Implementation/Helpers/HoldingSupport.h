#pragma once

/*
* Copyright (c) 2012 NaturalMotion Ltd. All rights reserved.
*
* Not to be copied, adapted, modified, used, distributed, sold,
* licensed or commercially exploited in any manner without the
* written consent of NaturalMotion.
*
* All non public elements of this software are the confidential
* information of NaturalMotion and may not be disclosed to any
* person nor used for any purpose not expressly approved by
* NaturalMotion in writing.
*
*/

#ifndef NM_SUPPORT_H
#define NM_SUPPORT_H

#include "AutoGenerated/NetworkForceInclude.h"
#include "AutoGenerated/Types/RotationRequest.h"

#ifndef NM_BEHAVIOUR_LIB_NAMESPACE
#error behaviour library namespace undefined
#endif

namespace NM_BEHAVIOUR_LIB_NAMESPACE
{
//----------------------------------------------------------------------------------------------------------------------
template<typename OwnerType, typename InType, typename OutType>
inline void updateHoldingSupport(OwnerType& owner, const ArmAndLegLimbSharedState& limbState, InType& in, OutType& out)
{
  if (limbState.m_isConstrained && (in->getEndDesiredTMImportance() > 0.0f))
  {
    const float importance = 1.0f;
    LimbControl& control = out->startControlModification();

    // When end is constrained, then the hold module feeds back the inverse of "fatigue" into
    // supportStrengthScale, i.e. when just constrained supportStrengthScale will be 1, and when the
    // constrained is about to give up it will be 0.
    control.reinit(
      owner->data->normalStiffness * in->getSupportStrengthScale(),
      owner->data->normalDampingRatio,
      owner->data->normalDriveCompensation);

    if (in->getTranslationRequestImportance() > 0.0f)
    {
      NMP::Vector3 targetRootPosition =
        limbState.m_rootTM.translation() + in->getTranslationRequest().translation;
      control.setExpectedRootPosForTarget(targetRootPosition, importance);
    }
    if (in->getRotationRequestImportance() > 0.0f)
    {
      // Apply the root rotation request to the root target
      NMP::Quat targetRootQuat =
        NMP::Quat(in->getRotationRequest().rotation, false) * limbState.m_rootTM.toQuat();
      control.setExpectedRootOrientationForTarget(targetRootQuat, importance);
    }

    NMP_ASSERT(in->getEndDesiredTM().isValidTM(0.1f))
      control.setTargetOrientation(in->getEndDesiredTM().toQuat(), importance);
    control.setTargetPos(limbState.m_endTM.translation(), importance);

    // Addition to allow for stronger arms, by using a strength scale > 1
    float forceMultiplier = NMP::clampValue(in->getSupportStrengthScale() * 0.5f, 0.0f, 1.0f);
    // Higher values will increase the maximum multiplication factor
    control.setSupportForceMultiplier(forceMultiplier);
    control.setGravityCompensation(forceMultiplier); // higher values will lift to required height
    control.setEndSupportAmount(1.0f);        // gets turned into bool to toggle gravity compensation
    control.setImplicitStiffness(1.0f);

    control.setControlAmount(ER::holdingSupportControl, 1.0f);
    out->stopControlModification(1.0f);
  }
}

//----------------------------------------------------------------------------------------------------------------------
template<typename OwnerType, typename DataType, typename FeedOutType>
inline void feedbackHoldingSupport(
  OwnerType& owner,
  DataType& data,
  const ArmAndLegLimbSharedState& limbState,
  FeedOutType& feedOut,
  float &controlAmount)
{
  if (limbState.m_isConstrained)
  {
    float constrainedAmount = (float) limbState.m_isConstrained;
    float endFixedAmount = NMP::maximum(owner->data->endOnGroundAmount, constrainedAmount);
    endFixedAmount = NMP::maximum(endFixedAmount, limbState.m_externalSupportAmount);
    float supportingAmount = endFixedAmount;

    // On the first feedback pretend that we were asked to support! This should stop other modules
    // kicking in like freefall, grab etc. Also, if we were previously supported externally (e.g.
    // using partial/full body HK) then we probably weren't receiving any collision info. That would
    // mean on the first update that follows we wouldn't know about the ground, and would do a
    // one-frame swing, which looks terrible. It's better to assume that we are on the ground, which
    // at its worst will enable the balancer and prevent immediate swing etc.
    if (!data->hasFeedbackRun)
    {
      data->hasFeedbackRun = true;
      supportingAmount = 1.0f;
    }
    if (limbState.m_externalSupportAmount > 0.0f)
    {
      data->hasFeedbackRun = false;
    }
    supportingAmount = NMP::clampValue(supportingAmount, 0.0f, 1.0f);

    // since control amounts are purposely summed in the body section this means that more limbs
    // controlling will provide a larger control amount currently the 0.25 roughly represents the
    // arm's stiffness but I should make it scale with the chosen arm stiffness.
    controlAmount = supportingAmount * 0.25f;

    feedOut->setSupportAmount(supportingAmount);
    feedOut->setSupportedByConstraint(true);
  }
}
}

#endif