#pragma once

/*
* Copyright (c) 2011 NaturalMotion Ltd. All rights reserved.
*
* Not to be copied, adapted, modified, used, distributed, sold,
* licensed or commercially exploited in any manner without the
* written consent of NaturalMotion.
*
* All non public elements of this software are the confidential
* information of NaturalMotion and may not be disclosed to any
* person nor used for any purpose not expressly approved by
* NaturalMotion in writing.
*
*/

#ifndef NM_REACHAUX_H
#define NM_REACHAUX_H

//----------------------------------------------------------------------------------------------------------------------
#include "AutoGenerated/NetworkForceInclude.h"
#include "NMPlatform/NMMatrix34.h"
#include "morpheme/mrInstanceDebugInterface.h"
#include "euphoria/erDimensionalScaling.h"

//----------------------------------------------------------------------------------------------------------------------

#ifndef NM_BEHAVIOUR_LIB_NAMESPACE
  #error behaviour library namespace undefined
#endif

namespace NM_BEHAVIOUR_LIB_NAMESPACE
{

//----------------------------------------------------------------------------------------------------------------------
/// function to determine if a point in space lies within a prism with triangular base
///
/// returns true if x is on or in front of the triangle plane false otherwise
/// (front and back are determined by the ordering of vertices which gives the sign of the
/// normal i.e. forwards direction)
///
/// corresponding bits of outCode are set for each edge that the projection of x in the plane of the triangle 
/// lies outside and so zero signals containment of x within the prism
///
bool pointInTrianglePrism(
  const NMP::Vector3& x,
  const NMP::Vector3& v0,
  const NMP::Vector3& v1,
  const NMP::Vector3& v2,
  uint32_t& outCode);

//----------------------------------------------------------------------------------------------------------------------
/// function to determine if a point is in front of the given triangle or not
NM_INLINE bool pointInFrontOfTriangle(
  const NMP::Vector3& x,
  const NMP::Vector3& v0,
  const NMP::Vector3& v1,
  const NMP::Vector3& v2)
{
  // the cross of any two (cyclically ordered) edges determines the triangle normal
  // degeneracy check, tho should not be necessary in this context,
  // det too small <==> degenerate triangle
  //
  NMP::Vector3 det = vCross(v1 - v0, v2 - v0);
  return (x - v0).dot(det) >= 0.0f;
}

//----------------------------------------------------------------------------------------------------------------------
/// In calcDisplacementLimitedTarget we want to clamp the displacement so that when moving at the
/// speed limit we don't induce any additional acceleration. This means that the standard
/// spring/damper drive gives:
/// accel = 0 = strength * posError - damping * velError
/// so posError = velError * damping / strength
/// Then damping = 2 * dampingRatio*stiffness and strength = stiffness*stiffness
/// so posError = velError * 2 * dampingRatio / stiffness
NM_INLINE float calcMaxDisplacement(float speedLimit, float dampingRatio, float stiffness)
{
  float maxDisplacement = 0.0f;
  if (stiffness > 0.0f)
  {
    maxDisplacement = speedLimit * 2.0f * dampingRatio / stiffness;
  }
  return maxDisplacement;
}

//----------------------------------------------------------------------------------------------------------------------
/// Given effector, target and a maximum (effector) displacement returns a new target no more than displacement
/// away from the effector (aux for velocity limiting).
NM_INLINE NMP::Vector3 calcDisplacementLimitedTarget(
  const NMP::Vector3& target,
  const NMP::Vector3& effector,
  const float maxDisplacement)
{
  NMP::Vector3 effectorToTarget(target - effector);
  float effectorToTargetDistance = effectorToTarget.magnitude();
  // clamp target if too far
  if (effectorToTargetDistance > maxDisplacement)
  {
    return effector + (effectorToTarget * (maxDisplacement / effectorToTargetDistance));
  }
  // or return input unchanged
  return target;
}

NM_INLINE NMP::Vector3 calcPointOnPlane(const NMP::Vector3& x, const NMP::Vector3& planeNormal, const NMP::Vector3& planePoint)
{
  NMP_ASSERT(planeNormal.isNormal(1e-3f));
  return x - (planeNormal.dot(x - planePoint) * planeNormal);
}

NM_INLINE NMP::Vector3 calcDirectionOnPlane(const NMP::Vector3& x, const NMP::Vector3& planeNormal)
{
  NMP_ASSERT(planeNormal.isNormal(1e-3f));
  return x - (planeNormal.dot(x) * planeNormal);
}

//----------------------------------------------------------------------------------------------------------------------
/// Function to limit (angular) distance between effector and reach target. One can think of this as
/// a method for swiveling a target about an axis going through some obstacle. It is used for
/// self-avoidance, to generate intermediate targets that will guide the effector around the torso.
/// In the above context, the reach frame is a frame centered on the chest with up direction taken
/// from character spine up, and forwards from the direction of the reach cone of the arm.
///
/// The adjusted target should be "closer" to the effector than the input target and hence more
/// attainable. How much closer is determined by angleLimit and angleFraction. The angleLimit is the
/// maximum angular displacement between effector and adjusted target, the angleFraction is the
/// fraction of the arc (effector to target). The adjusted target is found by rotating the input
/// target towards the effector about the reach frame up direction. The direction of rotation is in
/// the direction of the shortest arc from "reach-fwd" to target.
NMP::Vector3 calcAngleLimitedTarget(
  const NMP::Vector3& target,           ///< target position
  const NMP::Vector3& effector,         ///< effector position
  float               avoidanceRadius,  ///< self avoidance radius
  float               slackAngle,       ///< region in which the effector position determines the winding angle
  // outputs
  NMP::Vector3&       adjustedTargetApproach, ///< Line from reach origin to adjusted target
  float&              effectorToTargetAngle, ///< Angle
  // "reach frame" parameters define the frame of rotation (origin, up and forward)
  const NMP::Vector3& reachOrigin,            ///< origin (e.g. shoulder or chest)
  const NMP::Vector3& reachUp,                ///< up direction (eg. spine or chest up)
  const NMP::Vector3& reachFwd,               ///< forward (eg. reach cone direction)
  MR::InstanceDebugInterface* MR_OUTPUT_DEBUG_ARG(pDebugDrawInst),
  const ER::DimensionalScaling&   MR_OUTPUT_DEBUG_ARG(dimensionalScaling));

//----------------------------------------------------------------------------------------------------------------------
//
// Function to calculate the current angle between the reach and target.
//
// The angle is calculated with reference to the shortest arc between reachFwd and the target. The reach forward 
// direction is assumed to be something like the direction of the reach limit or the chest forward. In any case, a 
// direction that is relatively stable as compared with the effector.
// To avoid jitter when the reach forward direction is close to pi away from the target, the slackAngle parameter is
// provided to specify a deadzone (around pi) where priority is given to the actual effector position as opposed to the
// reach forward. This keeps the effector from repeatedly changing direction of winding about the spine.
//
//----------------------------------------------------------------------------------------------------------------------

float calcReachAngleToTarget(
  const NMP::Vector3& target,           // target position
  const NMP::Vector3& effector,         // effector position
  float slackAngle,                     // region in which the effector position determines the winding angle
  // "reach frame" parameters define the frame of rotation (origin, up and forward)
  const NMP::Vector3& reachOrigin,         // origin (e.g. shoulder or chest)
  const NMP::Vector3& reachUp,          // up direction (eg. spine or chest up)
  const NMP::Vector3& reachFwd,         // forward (eg. reach cone direction)
  MR::InstanceDebugInterface* MR_OUTPUT_DEBUG_ARG(pDebugDrawInst),
  const ER::DimensionalScaling*   MR_OUTPUT_DEBUG_ARG(dimensionalScaling));

//----------------------------------------------------------------------------------------------------------------------
/// Computes a new target position slid some distance along the desired approach normal. The magnitude of adjustment
/// depends on the length of the line of closest approach between effector and specfied approach direction. So the
/// adjustment to the given target is largest when the effector is far from the approach direction, tending to zero as
/// the effector approaches the line (aux for pathing an effector onto a suface target along a chosen approach direction).
NM_INLINE NMP::Vector3 reachApproachAdjustedTarget(
  const NMP::Vector3& target,
  const NMP::Vector3& targetNormal,
  const NMP::Vector3& effector,
  const NMP::Vector3& approachNormal,
  float penetration,
  float limbLength,
  float* targetAdjustment = (float*)0)
{
  // effector to target offset
  NMP::Vector3 effectorToTarget = target - effector;
  // line of closest approach from effector to approach direction
  NMP::Vector3 lineOfClosestApproach = effectorToTarget - (approachNormal.dot(effectorToTarget)) * approachNormal;

  // calc intermediate target for this frame
  float K = lineOfClosestApproach.magnitude();
  float tgtAdjustment = NMP::minimum(limbLength / 2.0f, K);
  if (targetAdjustment)
  {
    *targetAdjustment = tgtAdjustment;
  }
  return target + tgtAdjustment * approachNormal - penetration * targetNormal;
}

}

#endif