#pragma once

/*
* Copyright (c) 2012 NaturalMotion Ltd. All rights reserved.
*
* Not to be copied, adapted, modified, used, distributed, sold,
* licensed or commercially exploited in any manner without the
* written consent of NaturalMotion.
*
* All non public elements of this software are the confidential
* information of NaturalMotion and may not be disclosed to any
* person nor used for any purpose not expressly approved by
* NaturalMotion in writing.
*
*/

#ifndef NM_SITTING_SUPPORT_INL
#define NM_SITTING_SUPPORT_INL

#include "AutoGenerated/NetworkForceInclude.h"
#include "AutoGenerated/Types/RotationRequest.h"

// These are defined in LegSupportImpl.cpp so can be shared between leg and arm support
extern float g_supportForceMultipler;
extern float g_supportImplicitStiffness;

#ifndef NM_BEHAVIOUR_LIB_NAMESPACE
#error behaviour library namespace undefined
#endif

namespace NM_BEHAVIOUR_LIB_NAMESPACE
{
//----------------------------------------------------------------------------------------------------------------------
template<typename OwnerType, typename InType, typename OutType, typename DataType>
inline void updateSittingSupport(
  OwnerType& owner,
  InType& in, OutType& out, DataType& data, const ArmAndLegLimbSharedState& limbState,
  float timeStep,
  MR::InstanceDebugInterface* MR_OUTPUT_DEBUG_ARG(pDebugDrawInst))
{
  // Always apply at least just a tiny support amount (which may be overridden) so that legs don't
  // go completely floppy just because they've come off the ground.
  float endOnGroundAmount = NMP::clampValue(owner->data->endOnGroundAmount, 0.05f, 1.0f);

  if (in->getRootDesiredTMImportance() > 0.0f)
  {
    NMP::Matrix34 rootDesiredTM = in->getRootDesiredTM();
    MR_DEBUG_DRAW_MATRIX(pDebugDrawInst, rootDesiredTM, SCALE_DIST(1.0f));

    const ER::LimbTransform& rootTM = limbState.m_rootTM;
    const ER::HandFootTransform& endTM = limbState.m_endTM;

    MR_DEBUG_DRAW_VECTOR(
      pDebugDrawInst,
      MR::VT_Normal,
      limbState.m_endContact.lastPosition,
      limbState.m_endContact.lastNormal,
      NMP::Colour::LIGHT_PURPLE);

    // Rather than use the actual foot transform, work out where it would be if it were really
    // planted on the floor. This defines a coordinate frame on (perhaps floating above) the floor,
    // aligned along the length of the foot.
    NMP::Vector3 floorNormal;
    if (limbState.m_endContact.inContact)
    {
      floorNormal = limbState.m_endContact.lastNormal;
      // Don't use the actual floor position because this tends to be below the feet when they tilt,
      // and that just makes the tilting problem worse!
    }
    else
    {
      floorNormal = owner->owner->data->up;
    }
    ER::HandFootTransform floorTM;
    floorTM.createFromNormalAlignedByPoint(floorNormal, endTM.pointDirection(), endTM.translation());

    // Really just want to do "root" control, keeping the foot where it is. However, not convinced that works
    // too well - so convert to doing "end" control. Another reason for doing this is to avoid tilting our foot
    // further than necessary - i.e. if it's already tilted in a direction off the floor, don't tilt
    // any more in that direction.

    NMP::Matrix34 endDesiredTM;
    float strengthScale = 1.0f;
    float importance = 1.0f;
    float supportForceMultiplier = g_supportForceMultipler;
    float implicitStiffness = g_supportImplicitStiffness;

    // Update end off ground amount
    data->endOffGroundAmount += SCALE_TIME((owner->data->endGroundCollidingTime < 0.0f)? timeStep : -timeStep);
    data->endOffGroundAmount = NMP::clampValue(data->endOffGroundAmount, 0.0f, 1.0f);

    // Calculate target root TM by interpolating between current and desired root TM s.t. the affect on the root is 
    // increased the more the end effectors are on the ground.
    NMP::Matrix34 currentRootTM;
    currentRootTM.interpolate(rootTM, rootDesiredTM, data->endOffGroundAmount);

    // Find transform from current to desired root TM.
    NMP::Matrix34 currentToTargetRootTM;
    currentToTargetRootTM = rootDesiredTM;
    currentToTargetRootTM.invert();
    currentToTargetRootTM = currentRootTM * currentToTargetRootTM;

    // Find current end TM relative to root.
    NMP::Matrix34 currentEndRelativeToRootTM;
    currentEndRelativeToRootTM = currentRootTM;
    currentEndRelativeToRootTM.invert();
    currentEndRelativeToRootTM = endTM * currentEndRelativeToRootTM;

    // Blend in target pose for end effector, weighted by magnitude of difference between current and target root TM.
    const float targetRootRotationSq = currentToTargetRootTM.toRotationVector().magnitudeSquared();
    const float poseWeight = NMP::clampValue(1.0f - targetRootRotationSq, 0.0f, 0.5f);
    currentEndRelativeToRootTM.interpolate(in->getBalancePoseEndRelativeToRoot(), poseWeight);

    // Calculate desired end TM.
    endDesiredTM = currentEndRelativeToRootTM * currentToTargetRootTM * currentRootTM;

    // Could multiply this by strengthScale, but that multiplies up the strengthScale effect too
    // much. GC is already limited by the stiffness. Multiplying by strengthScale results in an odd
    // condition where as soon as the balanceWeakness > 0.5 he loses almost all strength. However,
    // we need to multiply since if we don't we end up in the situation where we output zero
    // strength with non-zero importance!
    float weight = NMP::clampValue(in->getRootDesiredTMImportance() * strengthScale, 0.0f, 1.0f);
    if (weight == 0.0f)
      return;

    LimbControl& control = out->startControlModification();

    float stiffness = NMP::clampValue(endOnGroundAmount * owner->data->normalStiffness * strengthScale,
      0.0f, owner->owner->data->maxStiffness);

    // Note that the drive compensation is set to 0 because otherwise the "floaty" bug occurs when
    // we run with small timesteps, leading to the stepping leg getting pushed out as he steps, and
    // balance becomes pretty bad.
    control.reinit(
      stiffness,
      owner->data->normalDampingRatio,
      owner->data->normalDriveCompensation * 0.0f);
    control.setTargetPos(endDesiredTM.translation(), importance);
    control.setTargetOrientation(endDesiredTM, importance);
    // used to be proportional to weight, but GC was mainly boolean anyway, so this is v close to the same
    control.setGravityCompensation(1.0f);
    control.setEndSupportAmount(endOnGroundAmount);

    control.setSupportForceMultiplier(supportForceMultiplier);
    control.setImplicitStiffness(implicitStiffness);

    control.setControlAmount(ER::sittingSupportControl, 1.0f);

    out->stopControlModification(weight);

    MR_DEBUG_DRAW_MATRIX(pDebugDrawInst, endTM, SCALE_DIST(0.5f));
    MR_DEBUG_DRAW_MATRIX(pDebugDrawInst, endDesiredTM, SCALE_DIST(0.25f));
    MR_DEBUG_DRAW_MATRIX(pDebugDrawInst, floorTM, SCALE_DIST(0.1f));
    MR_DEBUG_DRAW_LINE(pDebugDrawInst, endTM.translation(), endDesiredTM.translation(), NMP::Colour::TURQUOISE);
  }
}

//----------------------------------------------------------------------------------------------------------------------
template<typename OwnerType, typename InType, typename DataType, typename FeedOutType>
inline void feedbackSittingSupport(
  OwnerType& owner,
  InType& in,
  DataType& data,
  const ArmAndLegLimbSharedState& limbState,
  FeedOutType& feedOut)
{
  float constrainedAmount = (float) limbState.m_isConstrained;
  float endFixedAmount = NMP::maximum(owner->data->endOnGroundAmount, constrainedAmount);
  endFixedAmount = NMP::maximum(endFixedAmount, limbState.m_externalSupportAmount);
  float supportingAmount = endFixedAmount;

  if (limbState.m_externalSupportAmount == 0.0f && !limbState.m_isConstrained)
  {
    supportingAmount *= in->getRootDesiredTMImportance();
    if (in->getSupportStrengthScaleImportance() > 0.0f)
    {
      supportingAmount *= in->getSupportStrengthScale();
    }
    supportingAmount = NMP::clampValue(supportingAmount, 0.0f, 1.0f);
  }

  // On the first feedback pretend that we were asked to support! This should stop other modules
  // kicking in like freefall, grab etc. Also, if we were previously supported externally (e.g.
  // using partial/full body HK) then we probably weren't receiving any collision info. That would
  // mean on the first update that follows we wouldn't know about the ground, and would do a
  // one-frame swing, which looks terrible. It's better to assume that we are on the ground, which
  // at its worst will enable the balancer and prevent immediate swing etc.
  if (!data->hasFeedbackRun)
  {
    data->hasFeedbackRun = true;
    supportingAmount = 1.0f;
  }
  if (limbState.m_externalSupportAmount > 0.0f)
  {
    data->hasFeedbackRun = false;
  }
  supportingAmount = NMP::clampValue(supportingAmount, 0.0f, 1.0f);

  feedOut->setSupportAmount(supportingAmount);

  // The foot support point can be used by things like the support polygon
  float imp = NMP::maximum(supportingAmount, endFixedAmount);
  feedOut->setEndSupportPoint(limbState.m_endTM.translation(), imp);
}

#include "Helpers/SittingSupport.inl"

}

#endif 
