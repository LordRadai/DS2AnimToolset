#pragma once

/*
* Copyright (c) 2011 NaturalMotion Ltd. All rights reserved.
*
* Not to be copied, adapted, modified, used, distributed, sold,
* licensed or commercially exploited in any manner without the
* written consent of NaturalMotion.
*
* All non public elements of this software are the confidential
* information of NaturalMotion and may not be disclosed to any
* person nor used for any purpose not expressly approved by
* NaturalMotion in writing.
*
*/

#ifndef NM_STEP_INL
#define NM_STEP_INL

#include "AutoGenerated/NetworkForceInclude.h"
#include "AutoGenerated/Types/LimbControl.h"
#include "AutoGenerated/Types/StepParameters.h"
#include "euphoria/erEuphoriaLogger.h"

#ifndef NM_BEHAVIOUR_LIB_NAMESPACE
  #error behaviour library namespace undefined
#endif

namespace NM_BEHAVIOUR_LIB_NAMESPACE
{

//----------------------------------------------------------------------------------------------------------------------
template<typename OwnerType, typename InType, typename OutType, typename DataType>
inline void updateStep(
  OwnerType& owner,
  InType& in, OutType& out, DataType& data,
  float timeStep,
  StepType stepType,
  MR::InstanceDebugInterface* pDebugDrawInst)
{
  if (!in->getEnableStep())
    return;

  (void)pDebugDrawInst; // avoid compiler warning/error

  // Monopeds don't step
  uint32_t numLimbs = stepType == stepTypeLeg ? owner->owner->data->numLegs : owner->owner->data->numArms;
  if (numLimbs <= 1)
    return;

  const ArmAndLegLimbSharedState& limbState = (stepType == stepTypeLeg)
    ? owner->owner->data->legLimbSharedStates[owner->data->childIndex]
    : owner->owner->data->armLimbSharedStates[owner->data->childIndex];

  NMP_ASSERT(in->getStepParametersImportance() != 0.0f);
  const StepParameters& sp = in->getStepParameters();

  bool allowStep = in->getAllowStep();

  bool doRecoveryStep = in->getRecoveryStepTargetImportance() > 0.0f;
  // Continue to step even if it's not "allowed" if doing a recovery step... but only when
  // attempting to balance.
  allowStep |= doRecoveryStep || (data->isDoingRecoveryStep && in->getSupportTMImportance() > 0.0f);

  // Now check if we're actually going to step
  if (!allowStep)
  {
#ifdef USING_EUPHORIA_LOGGING
    if (data->isStepping)
      EUPHORIA_LOG_MESSAGE("--Stepping cancelled\n");
#endif // USING_EUPHORIA_LOGGING
    data->isStepping = false;
    MR_DEBUG_DRAW_POINT(pDebugDrawInst, data->stepTargetPos, SCALE_DIST(0.3f), NMP::Colour::BLACK);
    return;
  }

  // Use the floor normal in some calculations
  const NMP::Vector3 floorNormal =
    (in->getAverageEndContactNormalImportance() > 0.0f) ? in->getAverageEndContactNormal() : owner->owner->data->up;

  const ER::HandFootTransform& currentEndTM = limbState.m_endTM;
  const ER::LimbTransform& currentRootTM = limbState.m_rootTM;

  if (!data->isStepping)
  {
    // Start the step
    data->isStepping = true;
    data->hasEndLeftGround = false;
    data->stepTime = 0.0f;
    data->isDoingRecoveryStep = doRecoveryStep;
    if (doRecoveryStep)
      data->recoveryStepTarget = in->getRecoveryStepTarget();
  }
  MR_DEBUG_DRAW_POINT(pDebugDrawInst, data->stepTargetPos, SCALE_DIST(0.3f), NMP::Colour::YELLOW);

  const float stepUpDistance = sp.stepUpDistance;
  const float stepDownDistance = sp.stepDownDistance;

  const NMP::Vector3& currentEndPos = currentEndTM.translation();
  float horDistFromStart = NMP::vDot(currentEndPos - (data->averageOtherEndPos + data->stepStartDelta), data->stepDir);

  // lift the end up...
  float stepAimHeight = stepUpDistance * (data->stepLength - horDistFromStart) / data->stepLength;
  if (data->hasEndLeftGround)
  {
    // ...and push it down - ramp up the amount as it approaches the target
    stepAimHeight -= stepDownDistance * NMP::sqr(horDistFromStart / data->stepLength);
    // Avoid hovering feet
    stepAimHeight -= sp.stepDownSpeed * data->stepTime;

    // Reduce the lift for small steps
    if (stepAimHeight > 0.0f)
    {
      stepAimHeight *= data->stepLength / sp.maxStepLength;
    }
  }

  // endTargetPos is where we actually aim for, since we don't want to push the end forward/back
  // until it's actually off the floor. Also, the step ends when we're pushing the end down and
  // it touches the floor. Also, we will want a smooth transition to static balance, so we
  // should aim to position/orientate the end so that it will be trying to place the pelvis in
  // the right place when it is planted too.
  NMP::Vector3 endTargetPos = data->stepTargetPos + floorNormal * stepAimHeight;

  // When aiming below the ground move the target forward to reduce the chances of under-stepping.
  if (stepAimHeight < 0.0f)
    endTargetPos -= data->stepDir * stepAimHeight * 0.25f;

  MR_DEBUG_DRAW_POINT(pDebugDrawInst, data->averageOtherEndPos + data->stepStartDelta, SCALE_DIST(0.1f), NMP::Colour::BLUE);
  MR_DEBUG_DRAW_POINT(pDebugDrawInst, data->averageOtherEndPos, SCALE_DIST(0.1f), NMP::Colour::TURQUOISE);

  if (!data->hasEndLeftGround && owner->data->endOnGroundAmount < 1.0f)
  {
    data->hasEndLeftGround = true;
    EUPHORIA_LOG_MESSAGE("--End left ground\n");
  }

  // Check for stepping foot landing, which ends the step. Also end the step if the foot never left the ground.
  if ((data->hasEndLeftGround || stepAimHeight < 0.0f) && owner->data->endGroundCollidingTime > 0.0f)
  {
    // Don't stop the step if it's just catching momentarily on the ground - i.e. if it's still
    // moving relative to the floor
    float velInStepDir = (limbState.m_endData.velocity - in->getGroundVelocity()).dot(data->stepDir);
    if (velInStepDir < SCALE_VEL(0.1f))
    {
      data->isStepping = false;
      data->isDoingRecoveryStep = false;
      data->stepLength = 0.0f;
      EUPHORIA_LOG_MESSAGE(
        "--Stepping finished (leftGround = %d, aimHeight = %f, groundColTime = %f, velInStepDir = %f\n",
        data->hasEndLeftGround, stepAimHeight, owner->data->endGroundCollidingTime, velInStepDir);
      return;
    }
    else
    {
      EUPHORIA_LOG_MESSAGE("--Stepping not finished because foot still moving in step dir with vel %f\n", velInStepDir);
    }
  }

  // Set the control compensation to 0 when on the ground - so that catching the foot at the start
  // doesn't flip the character.
  float compensationMultiplier = 0.0f;
  if (owner->data->endOnGroundAmount < 1.0f && stepAimHeight > 0.0f)
    compensationMultiplier = 1.0f;

  float strengthScale = sp.strengthScale;
  if (stepType == stepTypeArm)
  {
    strengthScale *= (1.0f - sp.stepWeaknessPerArm[owner->data->childIndex]);
  }
  else
  {
    strengthScale *= (1.0f - sp.stepWeaknessPerLeg[owner->data->childIndex]);
  }

#if 0
  /// Reduce the damping for large steps as otherwise we tend to drag
  const float maxStepLength = GET_PARAM(g_steppingMaxStepLengthOverride, sp.maxStepLength);
  float dampingScale = NMP::clampValue(1.0f - data->stepLength / maxStepLength, 0.7f, 1.0f);
#else
  float dampingScale = 1.0f;
#endif
  dampingScale *= sp.dampingRatioScale;

  LimbControl& control = out->startControlModification();

  control.reinit(
    owner->data->normalStiffness * strengthScale,
    owner->data->normalDampingRatio * dampingScale,
    owner->data->normalDriveCompensation * compensationMultiplier);

  // We're aiming for a world position, so we could adjust our target so that the IK will reach it
  // after the physics step, assuming the root moves at its current velocity. However, it doesn't
  // really improve/change the result.
  control.setTargetPos(endTargetPos, 1.0f);

  // Compensate for motion of pelvis. This makes a big difference to the balance result. However,
  // compensating for the linear velocity makes things worse.
  control.setExpectedRootForTarget(
    currentRootTM, 1,
    NMP::Vector3::InitZero,
    limbState.m_rootData.angularVelocity);

  // Set the foot target orientation
  if (data->isDoingRecoveryStep && in->getSupportTMImportance() > 0.0f)
  {
    control.setTargetOrientation(data->recoveryStepTarget.toQuat(), sp.orientationWeight);
    MR_DEBUG_DRAW_MATRIX(pDebugDrawInst, NMP::Matrix34(data->recoveryStepTarget.toQuat(), endTargetPos), SCALE_DIST(sp.orientationWeight));
  }
  else
  {
    // Make the end normal follow an arc around the root
    NMP::Vector3 endTargetNormal = currentRootTM.translation() - endTargetPos;
    // Blend the normal back to vertical (relative to floor) too. This is needed partly because the
    // root may be horizontally offset (e.g. the zombie) - really we want to arc around the point
    // above the foot in the balance pose.
    endTargetNormal += floorNormal * sp.alignFootToFloorWeight;
    endTargetNormal.normalise();

    // If stepping forwards align feet with the step direction, if backwards then align opposite to
    // the step direction.
    ER::HandFootTransform endTM;
    if (currentRootTM.frontDirection().dot(data->stepDir) > sp.steppingDirectionThreshold)
    {
      endTM.createFromNormalAlignedByPoint(endTargetNormal, data->stepDir);
    }
    else
    {
      endTM.createFromNormalAlignedByPoint(endTargetNormal, -data->stepDir);
    }
    NMP::Quat endTargetOrient = endTM.toQuat();

    float orientationWeight = sp.orientationWeight;
    control.setTargetOrientation(endTargetOrient, orientationWeight);

    MR_DEBUG_DRAW_MATRIX(pDebugDrawInst, NMP::Matrix34(endTargetOrient, endTargetPos), SCALE_DIST(orientationWeight));
  }

  control.setGravityCompensation(sp.gravityCompensation);
  control.setEndSupportAmount(0.0f);
  control.setImplicitStiffness(sp.steppingImplicitStiffness);
  control.setControlAmount(ER::stepControl, 1.0f);
  if (stepAimHeight > 0.0f)
    control.setTargetDeltaStep(sp.IKSubstep);

  control.setCollisionGroupIndex((float) sp.collisionGroupIndex);
  // Increase the skin width to pretty well ensure that a contact record with the ground is
  // maintained throughout the step - this will prevent penetration when the stepping foot lands.
  control.setSkinWidthIncrease(SCALE_DIST(0.2f));

  out->stopControlModification();
  out->setUseFullEndJointRange(true);

  data->stepTime += timeStep;
}

//----------------------------------------------------------------------------------------------------------------------
// Projects point onto the plane passing through planePoint and with a normal planeNormal
inline NMP::Vector3 getPointProjectedOntoPlane(
  const NMP::Vector3& point, 
  const NMP::Vector3& planeNormal, 
  const NMP::Vector3& planePoint)
{
  return planePoint + (point - planePoint).getComponentOrthogonalToDir(planeNormal);
}

//----------------------------------------------------------------------------------------------------------------------
// Moves the step target out of the exclusion zone. Returns false if stepping should be prevented (i.e. the 
// foot is already in the exclusion zone and would want to step further into it.
template<typename OwnerType, typename FeedOutType, typename DataType>
inline bool applyExclusionPlane(
  const OwnerType& MR_OUTPUT_DEBUG_ARG(owner),
  const NMP::Vector3& plane,
  const NMP::Matrix34& currentEndTM,
  FeedOutType& feedOut,
  DataType& data,
  float deadZoneDist,
  MR::InstanceDebugInterface* MR_OUTPUT_DEBUG_ARG(pDebugDrawInst))
{
  float targetDistanceIntoExclusionZone = plane.dot(data->stepTargetPos) + plane.w;
  float endDistanceIntoExclusionZone = plane.dot(currentEndTM.translation()) + plane.w;
  MR_DEBUG_DRAW_VECTOR(pDebugDrawInst, MR::VT_Normal, currentEndTM.translation() - plane * endDistanceIntoExclusionZone,
    plane, NMP::Colour::RED);
  MR_DEBUG_DRAW_POINT(pDebugDrawInst, currentEndTM.translation() - plane * endDistanceIntoExclusionZone, SCALE_DIST(0.1f), NMP::Colour::RED);
  // Prevent stepping in to the exclusion zone at all if in the dead zone
  if (!data->isStepping &&
    targetDistanceIntoExclusionZone > endDistanceIntoExclusionZone &&
    endDistanceIntoExclusionZone > - deadZoneDist)
  {
    // Prevent step starting entirely
    feedOut->setIsSteppingBeingSuppressed(true);
    return false;
  }
  else if (targetDistanceIntoExclusionZone > 0.0f && endDistanceIntoExclusionZone < 0.0f)
  {
    // Limit step target from going into it when the foot is outside the exclusion zone.
    feedOut->setIsSteppingBeingSuppressed(true);
    data->stepTargetPos -= plane * targetDistanceIntoExclusionZone;
  }
  else if (endDistanceIntoExclusionZone > 0.0f && targetDistanceIntoExclusionZone > endDistanceIntoExclusionZone)
  {
    // Limit stepping further in when the foot is already inside the exclusion zone
    feedOut->setIsSteppingBeingSuppressed(true);
    data->stepTargetPos -= plane * (targetDistanceIntoExclusionZone - endDistanceIntoExclusionZone);
  }
  return true;
}

//----------------------------------------------------------------------------------------------------------------------
template<typename OwnerType, typename InType, typename FeedOutType, typename DataType>
inline void feedbackStep(
  OwnerType& owner,
  InType& in,
  FeedOutType& feedOut,
  DataType& data,
  const NMP::Vector3& avgOfEndPositions,
  float NMP_UNUSED(timeStep),
  StepType stepType,
  MR::InstanceDebugInterface* pDebugDrawInst)
{
  // Early out if the balancer doesn't want us to evaluate the stepping, and we're not already
  // stepping (if we're already stepping then the balancer may not be interested in our feedback
  // output, but we still need to run to update the step. If it wants us to stop stepping then we'll
  // detect that with enableStep).
  //if (!in->getEvaluateStep() && !data->isStepping)
  //  return;

  if (!in->getEnableStep())
    return;

  // Monopeds don't step
  uint32_t numLimbs = stepType == stepTypeLeg ? owner->owner->data->numLegs : owner->owner->data->numArms;
  if (numLimbs <= 1)
    return;

  const ArmAndLegLimbSharedState& limbState = (stepType == stepTypeLeg)
    ? owner->owner->data->legLimbSharedStates[owner->data->childIndex]
  : owner->owner->data->armLimbSharedStates[owner->data->childIndex];

  NMP_ASSERT(in->getStepParametersImportance() != 0.0f);
  const StepParameters& sp = in->getStepParameters();

  const ER::HandFootTransform& currentEndTM = limbState.m_endTM;
  const ER::LimbTransform& currentRootTM = limbState.m_rootTM;

  // Prevent and abort stepping if the legs have "collapsed"
  if (owner->data->endOnGroundAmount >= 1.0f)
  {
    float footToRootDist = (currentEndTM.translation() - currentRootTM.translation()).magnitude();
    float rootDownSpeed = limbState.m_rootData.velocity.dot(owner->owner->data->down);
    float limbLengthToAbort = sp.limbLengthToAbort;
    float rootDownSpeedToAbort = sp.rootDownSpeedToAbort;
    if (
      footToRootDist < limbLengthToAbort &&
      rootDownSpeed > rootDownSpeedToAbort
      )
    {
      EUPHORIA_LOG_MESSAGE("-- Aborting/preventing step since the leg is collapsed/collapsing\n");
      data->isStepping = false;
      feedOut->setIsSteppingBeingSuppressed(true);
      return;
    }
  }

  // Do some adjustment if on slopes - e.g. we want to take bigger steps
  const NMP::Vector3 floorNormal =
    (in->getAverageEndContactNormalImportance() > 0.0f) ? in->getAverageEndContactNormal() : owner->owner->data->up;

  // We assume that if we are stepping then all the other feet are pretty much stably planted on the
  // ground.
  data->averageOtherEndPos =
    (avgOfEndPositions * (float) numLimbs - currentEndTM.translation()) / (numLimbs - 1.0f);

  if (data->isDoingRecoveryStep)
  {
    data->stepTargetPos = data->recoveryStepTarget.translation();
  }
  else
  {
    // Direction of stepping - 1 is fwd, 0 is back
    NMP::Vector3 COMVelRelGround = owner->owner->data->bodyLimbSharedState.m_dynamicState.getVelocity() - in->getGroundVelocity();
    NMP::Vector3 COMVelRelGroundDir = COMVelRelGround.getNormalised();
    float fwdMotionAmount = COMVelRelGroundDir.dot(currentRootTM.frontDirection());
    fwdMotionAmount = (fwdMotionAmount + 1.0f) * 0.5f; // 1 is forward, 0 is back

    // Calculate the step target
    float COMPredictionTimeForward = sp.stepPredictionTimeForward;
    float COMPredictionTimeBackward = sp.stepPredictionTimeBackward;
    float COMPredictionTime = COMPredictionTimeForward * fwdMotionAmount +
      COMPredictionTimeBackward * (1.0f - fwdMotionAmount);

    NMP::Vector3 COMPos = owner->owner->data->bodyLimbSharedState.m_dynamicState.getPosition();

    // Move it in the direction that the character will likely fall during the step based on the
    // natural standing pose.
    // If there is no pose then give up - it's because we're not balancing anyway
    if (in->getStandingPoseEndRelativeToSupportImportance(owner->data->childIndex) == 0.0f)
    {
      return;
    }
    NMP::Vector3 extraPoseOffset =
        in->getStandingPoseEndRelativeToSupport(owner->data->childIndex).translation() -
        in->getAverageStandingPoseEndRelativeToSupport().translation();

    in->getSupportTM().rotateVector(extraPoseOffset);

    MR_DEBUG_DRAW_POINT(pDebugDrawInst, in->getSupportTM().translation() + extraPoseOffset, 
      SCALE_DIST(1.0f), NMP::Colour::DARK_GREY);

    extraPoseOffset = extraPoseOffset.getComponentOrthogonalToDir(owner->owner->data->up);
    float extraPoseAmount = sp.footSeparationFraction;
    extraPoseOffset *= extraPoseAmount;

    // Calculate the step target position
    data->stepTargetPos = COMPos + extraPoseOffset + COMVelRelGround  * COMPredictionTime;
  }

  // Place it "vertically" at the height of the average of the other feet
  data->stepTargetPos = getPointProjectedOntoPlane(data->stepTargetPos, owner->owner->data->up, data->averageOtherEndPos);
  // and then project onto the slope
  data->stepTargetPos = getPointProjectedOntoPlane(data->stepTargetPos, floorNormal, data->averageOtherEndPos);

  MR_DEBUG_DRAW_POINT(pDebugDrawInst, data->stepTargetPos, SCALE_DIST(0.1f), NMP::Colour::TURQUOISE);

  // Prevent excessive steps relative to the other end, or steps that would finish with the feet too
  // close.
  const float maxStepLength = sp.maxStepLength;

  NMP::Vector3 targetDeltaFromOtherEnd = data->stepTargetPos - data->averageOtherEndPos;
  float origLen = targetDeltaFromOtherEnd.magnitude();
  if (origLen > maxStepLength)
    targetDeltaFromOtherEnd *= maxStepLength / origLen;
  data->stepTargetPos = data->averageOtherEndPos + targetDeltaFromOtherEnd;

  // Clamp the step target according to the exclusion plane.
  if (sp.exclusionPlane.magnitudeSquared() > 0.0f)
  {
    const float deadZoneDist = SCALE_DIST(0.3f);
    if (!applyExclusionPlane(owner, sp.exclusionPlane, currentEndTM, feedOut, data, deadZoneDist, pDebugDrawInst))
    {
      return;
    }
  }

  // Optionally reduce foot crossing by setting up an exclusion plane based on the location of the
  // other foot (feet).
  if (sp.suppressFootCrossing)
  {
    const NMP::Vector3& averageOfDefaultEndsRelRoot = 
      owner->owner->data->averageLegDefaultPoseEndRelativeToRoot.translation();
    const NMP::Vector3 defaultEndRelRoot = 
      owner->owner->data->defaultPoseEndsRelativeToRoot[owner->data->limbNetworkIndex].translation();
    NMP::Vector3 otherFootPlane = currentRootTM.getRotatedVector(averageOfDefaultEndsRelRoot - defaultEndRelRoot);
    otherFootPlane = otherFootPlane.getComponentOrthogonalToDir(owner->owner->data->up);
    otherFootPlane.normalise();

    NMP::Vector3 point = data->averageOtherEndPos - otherFootPlane * sp.footCrossingOffset;
    otherFootPlane.w = -point.dot(otherFootPlane);
    if (!applyExclusionPlane(owner, otherFootPlane, currentEndTM, feedOut, data, 0.0f, pDebugDrawInst))
    {
      return;
    }
  }

  if (!data->isStepping)
  {
    // Don't modify whilst stepping
    data->stepStartDelta = currentEndTM.translation() - data->averageOtherEndPos;
    data->stepDir = data->stepTargetPos - currentEndTM.translation();
    data->stepDir = data->stepDir.getComponentOrthogonalToDir(floorNormal);
    data->stepLength = data->stepDir.normaliseGetLength();
  }
  else
  {
    float horDistFromStart = NMP::vDot(
      currentEndTM.translation() - (data->averageOtherEndPos + data->stepStartDelta), data->stepDir);
    float stepFraction = horDistFromStart / data->stepLength;
    feedOut->setStepFraction(NMP::clampValue(stepFraction, 0.0f, 1.0f));
  }
  data->stepDir = data->stepTargetPos - (data->averageOtherEndPos + data->stepStartDelta);
  data->stepDir = data->stepDir.getComponentOrthogonalToDir(floorNormal);
  data->stepDir.normalise();

  feedOut->setIsStepping(data->isStepping);
  feedOut->setIsDoingRecoveryStep(data->isDoingRecoveryStep);
  feedOut->setStepDir(data->stepDir);

  // Lower the pelvis when stepping so that the stance legs bends a little.
  if (data->isStepping)
  {
    float lowerRootDistance = data->stepLength * sp.lowerPelvisAmount;

    // Recalculate the heights of the target based on the normal of the surface the standing end is
    // currently on. Project up/down onto that plane. Since we're only using contacts to know about
    // the floor we can't calculate an accurate step target normal/position - we'd need to enable
    // environment awareness probes to do this (which would be expensive).

    // Request that the pelvis lowers when stepping down hill
    float lowerRootDistanceSlope = (data->averageOtherEndPos - data->stepTargetPos).dot(owner->owner->data->up);

    feedOut->setLowerRootDistance(lowerRootDistance + lowerRootDistanceSlope);
  }

  // Only produce feed output if we were asked for it - otherwise this limb will have an "advantage"
  // just as we stop stepping, and it will tend to get chosen to step immediately.
  if (in->getEvaluateStep())
  {
    feedOut->setStepLength(data->stepLength);
  }
}

}

#endif
