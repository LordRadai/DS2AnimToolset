// Copyright (c) 2010 NaturalMotion.  All Rights Reserved.
// Not to be copied, adapted, modified, used, distributed, sold,
// licensed or commercially exploited in any manner without the
// written consent of NaturalMotion.
//
// All non public elements of this software are the confidential
// information of NaturalMotion and may not be disclosed to any
// person nor used for any purpose not expressly approved by
// NaturalMotion in writing.

//----------------------------------------------------------------------------------------------------------------------
#ifdef _MSC_VER
  #pragma once
#endif
#ifndef MC_RUNTIMETARGETINTERFACE_H
#define MC_RUNTIMETARGETINTERFACE_H
//----------------------------------------------------------------------------------------------------------------------
#include "sharedDefines/mSharedDefines.h"
#include "comms/mcomms.h"
#include "comms/sceneObject.h"
//----------------------------------------------------------------------------------------------------------------------

namespace NMP
{
class Vector3;
class Matrix34;
class Quat;
struct PosQuat;
}

namespace MR
{
struct AttribTransformBufferOutputData;
struct AttribTrajectoryDeltaTransformOutputData;
class NetworkDef;
struct Message;
}

namespace MCOMMS
{
class Connection;
}

//----------------------------------------------------------------------------------------------------------------------
namespace MCOMMS
{

//----------------------------------------------------------------------------------------------------------------------
/// COMMS uses this interface to inform the application of connection status changes. Supplying an implementation of
/// this interface is optional.
class ConnectionManagementInterface
{
protected:

  /// ConnectionManagementInterface is a pure virtual interface.
  ConnectionManagementInterface() {}

public:

  virtual ~ConnectionManagementInterface() {}

public:

  /// \brief Called when a new connection is made to the target.
  virtual void onNewConnection(Connection* connection) = 0;

  /// \brief Called when a connection has been closed.
  virtual void onConnectionClosed(Connection* connection) = 0;

  /// \brief Called when a connection starts debugging a network instance.
  virtual void startDebuggingNetworkInstance(Connection* connection, InstanceID id) = 0;

  /// \brief Called when a connection stops debugging a network instance.
  virtual void stopDebuggingNetworkInstance(Connection* connection, InstanceID id) = 0;
};

//----------------------------------------------------------------------------------------------------------------------
/// The network instances on the runtime target are managed through this interface. This is the heart of the LiveLink
/// protocol and is a prerequisite for many other runtime target interfaces, for example the DataManagementInterface can
/// only be used on network instances advertised to COMMS by this interface. However, any concrete implementation may
/// choose to selectively hide network definitions or instances from inspection through this interface or in fact
/// advertise no instances at all (see NetworkManagerNull) which would effectively disable all network instance centric
/// LiveLink capabilities such as network inspection, debugging and preview.
class NetworkManagementInterface
{
protected:

  /// NetworkManagementInterface is a pure virtual interface.
  NetworkManagementInterface() {}

public:

  virtual ~NetworkManagementInterface() {}

public:

  /// \brief Returns the number of network definitions currently loaded.
  virtual uint32_t getNetworkDefCount() const = 0;

  /// \brief Stores the GUIDs associated with loaded network definitions in the provided array up to the maximum
  /// requested and returns the actual number of loaded network definitions or -1 if an error occurred.
  /// The GUID of a network definition is generated by morpheme:connect and made available to the runtime through the
  /// asset pipeline.
  virtual uint32_t getNetworkDefGUIDs(GUID* guids, uint32_t maxGuids) const = 0;

  /// \brief Returns if a network definition with the given GUID is already loaded.
  virtual bool isNetworkDefinitionLoaded(const GUID& guid) const = 0;

  /// \brief Returns the number of active network instances that available for query through this interface.
  virtual uint32_t getNetworkInstanceCount() const = 0;

  /// \brief Stores the IDs of active network instances in the provided array up to the maximum requested and returns
  /// the actual number of networks instances available or -1 if an error occurred.
  /// Instance IDs are generated by the client, morpheme:connect will not alter instance IDs in any way.
  virtual uint32_t getNetworkInstanceIDs(InstanceID* instanceIDs, uint32_t maxIntanceIDs) const = 0;

  /// \brief Returns the UTF-8 name of a network instance.
  virtual const char* getNetworkInstanceName(InstanceID id) const = 0;

  /// \brief Returns the GUID associated with the network definition of the given network instance.
  virtual bool getNetworkInstanceDefinitionGUID(InstanceID id, GUID& guid) const = 0;
};

//----------------------------------------------------------------------------------------------------------------------
/// Network definitions life cycles on the runtime target are managed through this interface. Support of this interface
/// is optional. If not supported morpheme:connect will not be able to load new destroy existing network definitions on
/// the target but may still create instances of already existing network definitions if the respective interfaces are
/// supported.
class NetworkDefLifecycleInterface
{
protected:

  /// NetworkDefLifecycleInterface is a pure virtual interface.
  NetworkDefLifecycleInterface() {}

public:

  virtual ~NetworkDefLifecycleInterface() {}

public:

  /// \brief Checks if this interface is supported or just a null implementation. If this method returns false it is
  /// implied that destroying network definitions is not supported either.
  /// The COMMS layer uses this information to communicate runtime capabilities to morpheme:connect.
  virtual bool canLoadNetworkDefinition() const = 0;

  /// \brief Instructs the application to load the NetworkDefinition of the
  /// given guid and file server path.
  /// \param connection can be used to transfer files over the network.
  /// The names of the files are determined by the assetCompiler
  /// application, and must be identifiable using only the guid and
  /// name passed in here.
  virtual bool loadNetworkDefinition(
    const GUID& guid,
    const char* networkDefName,
    Connection* connection) = 0;

  /// \brief Instructs the application that this NetworkDefinition
  /// is no longer required by morpheme:connect.
  virtual bool destroyNetworkDefinition(const GUID& guid) = 0;

  /// \brief Instructs the application that this all cached data should not be relied on
  /// This is used when connect detects a change to a source animation file.
  virtual bool clearCachedData() = 0;
};

//----------------------------------------------------------------------------------------------------------------------
/// Network instances life cycles on the runtime target are managed through this interface. Support of this interface is
/// optional. If not supported morpheme:connect will not be able to create new or destroy existing network instances on
/// the target but may still monitor existing network instances if the respective interfaces are supported.
class NetworkLifecycleInterface
{
protected:

  /// NetworkLifecycleInterface is a pure virtual interface.
  NetworkLifecycleInterface() {}

public:

  virtual ~NetworkLifecycleInterface() {}

public:

  /// \brief Checks if this interface is supported or just a null implementation. If this method returns false it is
  /// implied that destroying networks is not supported either.
  /// The COMMS layer uses this information to communicate runtime capabilities to morpheme:connect.
  virtual bool canCreateNetworkInstance() const = 0;

  /// \brief Called to request that an instance of the given network definition to be created. A Connection is passed in
  /// so that the application can destroy unused instances if the connection suddenly fails.
  /// \see DataManagementInterface::onConnectionClosed()
  /// \return The ID of the new network instance or MCOMMS::INVALID_INSTANCE_ID if an instance cannot be created.
  virtual InstanceID createNetworkInstance(
    const GUID&         guid,
    const char*         instanceName,
    uint32_t            animSetIndex,
    Connection*         connection,
    const NMP::Vector3& characterStartPosition = NMP::Vector3::InitZero,
    const NMP::Quat&    characterStartRotation = NMP::Quat::kIdentity) = 0;

  /// \brief Called to signal that a connection no longer
  /// requires the given instance.
  virtual bool destroyNetworkInstance(InstanceID id) = 0;

  /// \brief Called when a connection is closed.
  virtual void onConnectionClosed(Connection* connection) = 0;
};

//----------------------------------------------------------------------------------------------------------------------
/// Morpheme:connect uses a runtime target to preview animations in the asset browser, this interface is basis for the
/// runtime side implementation of that feature. Support for this interface is optional.
///
/// The interface is designed to allow browsing one animation network per connection. The animation (and network) data
/// required is to be loaded over the provided connection. The minimum requirements to support basic animation browsing
/// is to support loading animation sources and providing kAnimationDataSource data.
class AnimationBrowserInterface
{
protected:

  /// AnimationBrowserInterface is a pure virtual interface.
  AnimationBrowserInterface() {}

public:

  virtual ~AnimationBrowserInterface() {}

public:

  enum AnimationDataSources
  {
    kAnimationDataSource = 0,
    kRetargetDataSource,
    kRescaleDataSource,
    kNumDataSources
  };

  /// \brief Describes which nodes are which source in the animation browser network.
  struct NetworkDescriptor
  {
    const char* m_dataSourceNodeName[kNumDataSources];
  };

  /// \brief Checks if this interface is supported or just a null implementation.
  /// The COMMS layer uses this information to communicate runtime capabilities to morpheme:connect.
  virtual bool canLoadAnimSource() const = 0;

  /// \brief Checks to see if this interface can provide a specific piece of source data.
  /// The minimum that should be supported to preview animations is kAnimationDataSource.
  virtual bool canProvideAnimationBrowserDataSource(AnimationDataSources dataSource) const = 0;

  /// \brief Set the animation filename to be used for
  virtual bool setAnimationBrowserAnim(const char* animBrowserAnim, Connection* connection) = 0;

  /// \brief Set the animation network filename to be used by the animation browser
  virtual bool setAnimationBrowserNetwork(
    const char* animBrowserNetwork,
    NetworkDescriptor animBrowserNetworkDesc,
    Connection* connection) = 0;

  /// \brief Morpheme calls this to instruct the target to load new animation browser data from a known location
  /// The location and format of animation data is determined by a convention between the assetCompiler and target
  /// implementation.
  virtual bool loadAnimationBrowserData(const char* compressionType, Connection* connection) = 0;

  /// \brief Set the current time for the animation browser data in preparation for a call to
  /// getAnimationBrowserWorldTransforms(). The actual time the animation will be evaluate at is returned.
  virtual float setAnimationBrowserTime(float time, Connection* connection) = 0;

  /// \brief Get the current time for the animation browser data
  virtual float getAnimationBrowserTime(Connection* connection) = 0;

  /// \brief Return the duration in seconds of the current animation
  virtual float getAnimationBrowserDuration(Connection* connection) = 0;

  /// \brief Returns the size of a chunk of source data, if there is no data available returns 0.
  virtual uint32_t getAnimationBrowserTransformDataSourceSize(
    AnimationDataSources dataSource,
    Connection* connection) = 0;

  /// \brief Return the transforms attrib data for the requested data source.
  virtual bool serializeAnimationBrowserDataSource(
    AnimationDataSources dataSource,
    MR::AttribTransformBufferOutputData* data,
    Connection* connection) = 0;

  /// \brief Broadcast the specified message to the embedded network used to preview animations. Please note that the dataBuffer is owned by COMMS and will 
  /// be reused in subsequent calls. The data in this buffer should be copied into a location owned by the target. The format
  /// of the data is determined by the Message lua serialize function
  virtual bool broadcastAnimationBrowserMessage(const MR::Message& message, Connection* connection) = 0;

  /// \brief send the specified message to a specified node.  Please note that the dataBuffer is owned by COMMS and will 
  /// be reused in subsequent calls. The data in this buffer should be copied into a location owned by the target. The format
  /// of the data is determined by the Message lua serialize function
  virtual bool sendAnimationBrowserMessage(commsNodeID nodeID, const MR::Message& message, Connection* connection) = 0;

  /// \brief set the output animation set from the animation browser network.
  virtual bool setAnimationBrowserActiveAnimationSet(MR::AnimSetIndex setIndex, Connection* connection) = 0;

  /// \brief Sets the given control parameter to the given value. This is called by COMMS if the associated slider in
  /// morpheme:connect is moved while connected to the runtime.
  ///
  /// If type is NODE_OUTPUT_DATA_TYPE_FLOAT cparamData must point to a single 32-bit float.
  /// if type is NODE_OUTPUT_DATA_TYPE_VECTOR3 cparamData must point to an array of three 32-bit floats.
  /// if type is NODE_OUTPUT_DATA_TYPE_VECTOR4 cparamData must point to an array of four 32-bit floats.
  /// if type is NODE_OUTPUT_DATA_TYPE_BOOL cparamData must point to a single 32-bit integer with value 0 or 1
  /// if type is NODE_OUTPUT_DATA_TYPE_INT cparamData must point to a single 32-bit integer.
  /// if type is NODE_OUTPUT_DATA_TYPE_UINT cparamData must point to a single 32-bit unsigned integer.
  /// if type is NODE_OUTPUT_DATA_TYPE_PHYSICS_OBJECT_POINTER cparamData must point to a single pointer.
  virtual bool setAnimationBrowserControlParameter(
    commsNodeID            nodeID,
    MR::NodeOutputDataType type,
    const void*            cparamData,
    Connection* connection) = 0;


  /// \brief Called when a connection is closed.
  virtual void onConnectionClosed(Connection* connection) = 0;
};

//----------------------------------------------------------------------------------------------------------------------
/// Environment attributes on the runtime target are managed through this interface. Support of this interface is
/// optional. Morpheme:connect will only ever write but never read environment attributes, the get methods are provided
/// for runtime use only and specific implementations may choose to provide direct access to certain semantics instead.
class EnvironmentManagementInterface
{
protected:

  /// EnvironmentManagementInterface is a pure virtual interface.
  EnvironmentManagementInterface() {}

public:

  virtual ~EnvironmentManagementInterface() {}

public:

  /// \bried Checks if this interface is supported or just a null implementation.
  /// The COMMS layer uses this information to communicate runtime capabilities to morpheme:connect.
  virtual bool canEditEnvironmentAttributes() const = 0;

  /// \brief Requests the given attribute to be added to the environment, if an attribute of the same semantic already
  /// exists it is updated. Returns true if the attribute has been successfully added/update or false otherwise.
  /// The validity of the given attribute is only guaranteed for the runtime of this method, implementations must create
  /// a local copy if accessing the attribute from outside this method.
  virtual bool setEnvironmentAttribute(const Attribute* attribute) = 0;

public:

  /// \brief Queries the number of attributes of the environment.
  virtual uint32_t getEnvironmentNumAttributes() = 0;

  /// \brief Returns the environment attribute at the given index or NULL if the index is invalid.
  virtual Attribute* getEnvironmentAttribute(uint32_t index) = 0;

  /// \brief Returns the environment attribute at the given index or NULL if the index is invalid.
  virtual const Attribute* getEnvironmentAttribute(uint32_t index) const = 0;

  /// \brief Returns the environment attribute with the given semantic or NULL if the such an attribute does not exist.
  virtual Attribute* getEnvironmentAttribute(Attribute::Semantic semantic) = 0;

  /// \brief Returns the environment attribute with the given semantic or NULL if the such an attribute does not exist.
  virtual const Attribute* getEnvironmentAttribute(Attribute::Semantic semantic) const = 0;
};

//----------------------------------------------------------------------------------------------------------------------
/// Scene objects on the runtime target are managed through this interface. Support of this interface is optional.
/// If the interface is not supported or only editing of scene objects is allowed, morpheme:connect will not attempt to
/// create scene objects on the target. The target may still create scene objects on runtime side and advertise those
/// to active sessions.
class SceneObjectManagementInterface
{
protected:

  /// SceneObjectManagementInterface is a pure virtual interface.
  SceneObjectManagementInterface() {}

public:

  virtual ~SceneObjectManagementInterface() {}

public:

  /// \brief Checks if the implementation of this interface supports creation of scene objects.
  /// The COMMS layer uses this information to communicate runtime capabilities to morpheme:connect.
  virtual bool canCreateSceneObjects() const = 0;

  /// \brief Checks if the implementation of this interface permits editing of scene objects. As this cannot be enforced
  /// through the implementation of the interface (scene object attributes can be accessed directly on the same) this
  /// capability relies on COMMS respecting the implementations preference.
  virtual bool canEditSceneObjects() const = 0;

  /// \brief Returns the number of scene objects available on the runtime target.
  virtual uint32_t getNumSceneObjects() const = 0;

  /// \brief Requests that a scene object be added with the given attributes. The validity of the given attributes is
  /// only guaranteed for the duration of the call, implementations must create local copies of attributes retained for
  /// later use.
  virtual SceneObject* createSceneObject(
    uint32_t numAttributes,
    const Attribute* const* attributes,
    Connection* owner,
    SceneObject *&createdCharacterController) = 0;

  /// \brief Signals the application the the specified object is no longer
  /// required by connect.
  virtual bool destroySceneObject(SceneObjectID objectID, SceneObjectID& destroyedCharacterController) = 0;

  /// \brief Stores up to the given maximum number of runtime scene object in the provided list (in no particular order)
  /// and returns the number of scene objects available.
  virtual uint32_t getSceneObjects(SceneObject** objects, uint32_t maxObjects) const = 0;

  /// \brief Returns the scene object associated with the given ID or NULL.
  virtual SceneObject* getSceneObject(SceneObjectID objectID) const = 0;

  /// \brief Called when a connection is closed.
  virtual void onConnectionClosed(Connection* connection) = 0;
};

//----------------------------------------------------------------------------------------------------------------------
/// COMMS uses this interface to manipulate the world described by the physics engine. Connect makes use of this interface
/// to apply forces to the character and scene and to create and manipulate constraints to apply mouse forces.  Support of
/// this interface is optional, and it does not require additional interfaces to function correctly.  
class PhysicsManipulationInterface
{
protected:
  PhysicsManipulationInterface() {}
public: 
  virtual ~PhysicsManipulationInterface() {}

  /// \brief Checks if the implementation supports constraint creation and manipulation
  /// The COMMS layer uses this information to communicate runtime capabilities to morpheme:connect.
  virtual bool canCreateAndEditConstraints() const = 0;

  /// \brief Checks if the implementation supports the application of forces
  /// The COMMS layer uses this information to communicate runtime capabilities to morpheme:connect.
  virtual bool canApplyForces() const = 0;

  /// \brief Checks if the implementation supports the setting of rigid body transforms
  /// The COMMS layer uses this information to communicate runtime capabilities to morpheme:connect.
  virtual bool canSetAttributes() const = 0;

  /// \brief Create a new constraint on an object in the physics world. The object can be part of a scene or character.
  /// The constraintGUID is generated by connect to ensure that the constraints can be created by multiple instances
  /// without collision or the need for acknowledgment from runtime.  The constraint parameters include the local space
  /// position of the constraint relative to the body in the physics engine referenced by the physicsEngineObjectID.  It
  /// also stores the requested location of the constraint itself, which will not necessarily match the transformed 
  /// world space position of the local space constraint due to asynchronous communication.  An offset should be stored 
  /// with the constraint to account for these differences.
  virtual bool createConstraint(uint64_t constraintGUID,
                                uint32_t physicsEngineObjectID,
                                const NMP::Vector3& localSpaceConstraintPosition,
                                const NMP::Vector3& worldSpaceConstraintPosition,
                                bool constrainOrientation,
                                bool constrainAtCentreOfMass,
                                const NMP::Vector3& sourceRayWSPositionHint,
                                const NMP::Vector3& sourceRayWSDirectionHint
                                ) = 0;

  /// \brief Move the constraint with the given GUID to the specified location
  /// Please note that moveConstraint commands will be issued without waiting for acknowledgment from the runtime that
  /// the constraint has been successfully created.  
  virtual bool moveConstraint(uint64_t constraintGUID, const NMP::Vector3& worldSpaceConstraintPosition) = 0;

  /// \brief Destroy the constraint with the given GUID 
  /// Please note that a removeConstraint command may be issued for a GUID that was not created by the runtime.  To 
  /// accommodate fast mouse drags connect does not wait for round trip communication when sending create, move, and 
  /// remove commands.  
  virtual bool removeConstraint(uint64_t constraintGUID) = 0;

  enum ForceMode
  {
    kFORCE, // treat the force as a standard force
    kIMPULSE, // treat the force as an impulse
    kVELOCITY_CHANGE // the force is specified as a desired velocity change 
  };

  /// \brief Apply a force to the object with the given ID.
  /// The force can be specified as a standard force, an impulse, or as a desired change in velocity.  If   
  /// applyATCOM is true the localSpacePosition and worldSpacePosition will not be used. 
  virtual bool applyForce(uint32_t physicsEngineObjectID, 
    ForceMode mode,
    const NMP::Vector3& force,
    bool applyAtCOM,
    const NMP::Vector3& localSpacePosition,
    const NMP::Vector3& worldSpacePosition
    ) = 0;

  /// \brief Set the attribute on the object with the given ID.
  virtual bool setPhysicsObjectAttribute(uint32_t physicsEngineObjectID,
      const MCOMMS::Attribute* physicsObjAttribute) = 0;
};

//----------------------------------------------------------------------------------------------------------------------
class DataManagementInterface
{
protected:

  /// DataManagementInterface is a pure virtual interface.
  DataManagementInterface() {}

public:

  virtual ~DataManagementInterface() {}

public:

  /// \brief Checks if the implementation supports state machine control.
  /// The COMMS layer uses this information to communicate runtime capabilities to morpheme:connect.
  virtual bool canSendStateMachineRequests() const = 0;

  /// \brief Checks if the implementation supports setting of control parameters.
  /// The COMMS layer uses this information to communicate runtime capabilities to morpheme:connect.
  virtual bool canSetControlParameters() const = 0;

  /// \brief Checks if the implementation supports changing a networks active animation set.
  /// The COMMS layer uses this information to communicate runtime capabilities to morpheme:connect.
  virtual bool canSetNetworkAnimSet() const = 0;

  /// \brief Queries the runtime for the name of the given semantic.
  virtual const char* getSemanticName(MR::AttribDataSemantic semantic) = 0;

  /// \brief Return serialize the animation rig details
  virtual bool serializeTxAnimRigDefData(const MCOMMS::GUID& networkGUID, MR::AnimSetIndex index, MCOMMS::Connection* connection) = 0;

  /// \brief Return the largest number of transforms used in any configuration of the given instance.
  virtual uint32_t getMaxTransformCount(InstanceID id) = 0;

  /// \brief Return the current number of transforms for the given instance.
  virtual uint32_t getCurrentTransformCount(InstanceID id) = 0;

  /// \brief Calculates the world space output of the given instance and returns it in the provided buffer.
  virtual bool getWorldTransforms(InstanceID id, uint32_t numTransforms, NMP::PosQuat* buffer) = 0;

  /// \brief Calculates the world space output of the given instance and returns it in the provided buffer.
  virtual bool getLocalTransforms(InstanceID id, uint32_t numTransforms, NMP::PosQuat* buffer) = 0;

  /// \brief Return the current frame's trajectory delta for the given instance.
  virtual bool getTransformChange(InstanceID id, NMP::Vector3& deltaTranslation, NMP::Quat& deltaOrientation) = 0;

  /// \brief Returns the number of active nodes in the given network instance..
  virtual uint32_t getActiveNodeCount(InstanceID id) = 0;

  /// \brief Copies the list of active nodes into the specified buffer up to the maximum specified and returns the
  /// number of nodes actually available which may be larger or -1 if an error occurred. This is used by
  /// morpheme:connect to highlight nodes in the network window.
  virtual uint32_t getActiveNodes(InstanceID id, commsNodeID* nodeIDs, uint32_t maxNodeIDs) = 0;

  /// \brief Returns the Node ID of the root state in the given state machine.
  virtual commsNodeID getRootStateNodeID(InstanceID id, commsNodeID stateMachineNodeID) = 0;

  /// \brief Returns the number of triggered node event messages in the given network instance.
  virtual uint32_t getTriggeredNodeEventMessageCount(InstanceID id) = 0;

  /// \brief  Copies the list of triggered node event messages into the specified buffer up to the maximum specified
  /// and returns the number of nodes actually available which may be larger or -1 if an error occurred.
  virtual uint32_t getTriggeredNodeEventMessages(InstanceID id, NetworkMessageID* messageIDs, uint32_t maxMessages) = 0;

  /// \brief Retrieves the information on the weights used in the scatter blend node specified.
  virtual bool getScatterBlendWeightData(
    MCOMMS::InstanceID id, MCOMMS::commsNodeID scatterBlendNodeID,
    float (&barycentricWeights)[3],
    MCOMMS::commsNodeID (&childNodeIDs)[3],
    float (&desiredMotionParams)[2],
    float (&achievedMotionParams)[2],
    bool& wasProjected) = 0;

  /// \brief Returns the active animation set for the given network instance.
  virtual uint32_t getActiveAnimationSet(InstanceID id) = 0;

  /// \brief Return the number of animation sets in the given network definition.
  virtual uint32_t getAnimSetCount(InstanceID id) const = 0;

  /// \brief Returns the number of nodes in the given network instance.
  virtual uint32_t getNodeCount(InstanceID id) = 0;

  /// \brief Returns the node type for the given node.
  virtual uint32_t getNodeTypeID(InstanceID id, commsNodeID nodeID) = 0;

  /// \brief Returns the UTF-8 name of the given node.
  virtual const char* getNodeName(InstanceID id, commsNodeID nodeID) = 0;

  /// \brief Returns the number of tags 
  virtual uint32_t getNodeTagCount(InstanceID id, commsNodeID nodeID) = 0;

  /// \brief Returns the UTF-8 tag for the given node and index 
  virtual const char* getNodeTag(InstanceID id, commsNodeID nodeID, uint32_t index) = 0;

  /// \brief Return the UTF-8 name of the give request.
  virtual const char* getMessageName(InstanceID id, NetworkMessageID requestID)  = 0;

  /// \brief Returns the request ID of the given request.
  virtual NetworkMessageID getMessageID(InstanceID id, const char* utf8Name) = 0;

  /// \brief Return the number of animation sets in the given network definition.
  virtual uint32_t getAnimSetCount(const GUID& guid) const = 0;

  /// \brief Return the number of node definitions in the given network definition.
  virtual uint32_t getNodeCount(const GUID& guid) const = 0;

  /// \brief Returns the node type for the given node.
  virtual MR::NodeType getNodeTypeID(const GUID& guid, commsNodeID nodeID) const = 0;

  /// \brief Return the number of message definitions in the given network definition.
  virtual uint32_t getMessageCount(const GUID& guid) const = 0;

  /// \brief Returns the UTF-8 name of the given node.
  virtual const char* getNodeName(const GUID& guid, commsNodeID nodeID) const = 0;

  /// \brief Returns the number of tags 
  virtual uint32_t getNodeTagCount(const GUID& guid, commsNodeID nodeID) const = 0;

  /// \brief Returns the UTF-8 tag for the given node and index 
  virtual const char* getNodeTag(const GUID& guid, commsNodeID nodeID, uint32_t index) const = 0;

  /// \brief Return the UTF-8 name of the given request.
  virtual const char* getMessageName(const GUID& guid, NetworkMessageID messageID) const = 0;

  /// \brief Copies the list of request IDs into the specified buffer up to the maximum specified and returns the number
  /// of requests actually available which may be larger or -1 if an error occurred.
  virtual uint32_t getMessageIDs(const GUID& guid, NetworkMessageID* messageIDs, uint32_t maxMessageIDs) const = 0;

  /// \brief Requests the application's current frame index. This is used to determine whether frame information has
  /// been lost.
  virtual uint32_t getFrameIndex() = 0;

  /// \brief COMMS calls this once per frame to signal that connect has finished transferring data for a given frame.
  /// \param dt Indicates the time-interval for the next frame requested by connect. This is varied in response to the
  /// slow motion widget in connect.
  virtual bool setStepInterval(float dt) = 0;

  /// \brief COMMS calls this to signal a change in the expected frame rate for the runtime target main loop.
  /// The value is decoupled from the step interval for versatility reasons, but ideally the settings would satisfy the
  /// equation 1/dt = fps.
  /// \param fps Indicates the expected frames per second.
  virtual bool setFrameRate(float fps) = 0;

  /// \brief Broadcast the specified message across the whole network. Please note that the dataBuffer is owned by COMMS and will 
  /// be reused in subsequent calls. The data in this buffer should be copied into a location owned by the target. The format
  /// of the data is determined by the Message lua serialize function
  virtual bool broadcastMessage(InstanceID id, const MR::Message& message) = 0;

  /// \brief send the specified message to a specified node.  Please note that the dataBuffer is owned by COMMS and will 
  /// be reused in subsequent calls. The data in this buffer should be copied into a location owned by the target. The format
  /// of the data is determined by the Message lua serialize function
  virtual bool sendMessage(InstanceID id, commsNodeID nodeID, const MR::Message& message) = 0;

  /// \brief Request that a state machine switch state to the id specified on the next frame. This function will fail
  /// if the given root state is not a child state of the given state machine.
  virtual bool setCurrentState(InstanceID id, commsNodeID stateMachineNodeID, commsNodeID newRootStateID) = 0;

  /// \brief Sets the given control parameter to the given value. This is called by COMMS if the associated slider in
  /// morpheme:connect is moved while connected to the runtime.
  ///
  /// If type is NODE_OUTPUT_DATA_TYPE_FLOAT cparamData must point to a single 32-bit float.
  /// if type is NODE_OUTPUT_DATA_TYPE_VECTOR3 cparamData must point to an array of three 32-bit floats.
  /// if type is NODE_OUTPUT_DATA_TYPE_VECTOR4 cparamData must point to an array of four 32-bit floats.
  /// if type is NODE_OUTPUT_DATA_TYPE_BOOL cparamData must point to a single 32-bit integer with value 0 or 1
  /// if type is NODE_OUTPUT_DATA_TYPE_INT cparamData must point to a single 32-bit integer.
  /// if type is NODE_OUTPUT_DATA_TYPE_UINT cparamData must point to a single 32-bit unsigned integer.
  /// if type is NODE_OUTPUT_DATA_TYPE_PHYSICS_OBJECT_POINTER cparamData must point to a single pointer.
  virtual bool setControlParameter(
    InstanceID             id,
    commsNodeID            nodeID,
    MR::NodeOutputDataType type,
    const void*            cparamData) = 0;

  /// \brief Sets which components of available debug info the runtime should continue to transmit.
  /// \see CoreDebugInterface::eDebugOutputFlags
  virtual bool setDebugOutputFlags(InstanceID id, uint32_t flags) = 0;

  /// \brief (Un)flags the given semantics as required for debugging on the given nodes.
  virtual bool setDebugOutputOnNodes(
    InstanceID              id,
    bool                    on,              // Turn output on or off.
    bool                    allNodes,        // Affect all or a set of nodes.
    bool                    allSemantics,    // Affects all or a set of semantics.
    uint32_t                numNodeIDs,      // Number of node IDs stored in the nodeIDs array.
    commsNodeID*            nodeIDs,
    uint32_t                numSemantics,    // Number of semantics stored in the semantics array.
    MR::AttribDataSemantic* semantics) = 0;

  /// \brief Requests that a specific type of data type should be stored for use by connect. This is typically used for
  /// obtaining control parameter information and node output for rendering sub-network output in connect.
  virtual bool enableOutputDataBuffering(
    InstanceID             id,
    commsNodeID            nodeID,
    MR::NodeOutputDataType dataType,
    bool                   enable) = 0;

  /// \brief Returns the number of node outputs recorded for the given instance.
  virtual uint32_t getNodeOutputCount(InstanceID id) = 0;

  /// \brief Returns the node ID of the outputIndex-th node output.
  virtual commsNodeID getNodeOutputNodeID(InstanceID id, uint32_t outputIndex) = 0;

  /// \brief Returns the output data type of the outputIndex-th node output.
  virtual MR::NodeOutputDataType getNodeOutputDataType(InstanceID id, uint32_t outputIndex) = 0;

  /// \brief Returns the length in bytes of the data from the outputIndex-th node output. Additional values are returned
  /// in the referenced parameters.
  virtual uint32_t getNodeOutputDataLength(
    InstanceID              id,
    uint32_t                outputIndex,
    MR::NodeID&             owningNodeID,
    MR::NodeID&             targetNodeID,
    MR::AttribDataType&     attribType,
    MR::AttribDataSemantic& attribSemantic,
    MR::AnimSetIndex&       animSetIndex,
    MR::FrameCount&         validFrame) = 0;

  /// \brief Copies the data forming the outputIndex-th node output into the provided buffer. This is used, along with
  /// getNodeOutputCount(), getNodeOutputNodeID(), getNodeOutputDataType() and getNodeOutputDataLength by COMMS to
  /// transfer the requested node output data to morpheme:connect each frame.
  virtual bool getNodeOutputData(InstanceID id, uint32_t outputIndex, void* destBuffer, uint32_t bufferLength) = 0;

  virtual bool serializeTxNodeTimings(InstanceID id, Connection* connection) = 0;
  virtual bool serializeTxControlParamAndOpNodeAttribData(InstanceID id, Connection* connection) = 0;
  virtual bool serializeTxTreeNodeAttribData(InstanceID id, Connection* connection) = 0;

  /// \brief Sends an animation set selection request to a given network instance.
  virtual bool setActiveAnimationSet(InstanceID id, uint32_t animSetIndex) = 0;

  /// \brief Execute a command on the specified network instance.
  /// The runtime target is free to interpret the command as required.
  virtual bool executeCommand(InstanceID id, const char* command) = 0;

  /// \brief Called when a connection is closed.
  virtual void onConnectionClosed(Connection* connection) = 0;

  /// \brief Move the root of the network to the specified transform.
  virtual bool setRootTransform(InstanceID id, const NMP::PosQuat& rootTransform) = 0;

  /// \brief True if the runtime target has been requested to simulate.  Networks should not be updated with a
  ///  delta time of greater than 0.0f if this is false.
  virtual bool isSimulating() const = 0;

  /// \brief Called when a simulation is started
  virtual void beginSimulation() = 0;

  /// \brief Called when a simulation is ended due to a user request or the master connection being closed.
  virtual void endSimulation() = 0;
};

//----------------------------------------------------------------------------------------------------------------------
class PhysicsDataManagementInterface
{
protected:
  /// PhysicsDataManagementInterface is a pure virtual interface.
  PhysicsDataManagementInterface() {}

public:

  virtual ~PhysicsDataManagementInterface() {}

  virtual void getPhysicsEngineID(char* buffer, uint32_t bufferLength) const = 0;

  virtual MR::AnimSetIndex getPhysicsRigDefCount(const GUID& guid) = 0;

  virtual bool serializeTxPhysicsRigDefData(const GUID& guid, MR::AnimSetIndex index, Connection* connection) = 0;
  virtual bool serializeTxPhysicsRigPersistentData(InstanceID id, uint32_t index, Connection* connection) = 0;
  virtual bool serializeTxPhysicsRigFrameData(InstanceID id, Connection* connection) = 0;

  virtual void onEnvironmentVariableChange(const Attribute* attribute) = 0;
};

// forward declaration, this is only needed in euphoria runtime targets.
class EuphoriaDataManagementInterface;

//----------------------------------------------------------------------------------------------------------------------
class PlaybackManagementInterface
{
public:

  virtual ~PlaybackManagementInterface() {}

  virtual bool canStepInSynch() const = 0;
  virtual bool canPause() const = 0;
  virtual bool canChangeDeltaTime() const = 0;
};

//----------------------------------------------------------------------------------------------------------------------
class RuntimeTargetInterface
{
public:

  RuntimeTargetInterface(
    ConnectionManagementInterface*    connectionManager,
    AnimationBrowserInterface*        animationBrowser,
    NetworkManagementInterface*       networkManager,
    NetworkDefLifecycleInterface*     networDefkLifecycle,
    NetworkLifecycleInterface*        networkLifecycle,
    EnvironmentManagementInterface*   environmentManager,
    SceneObjectManagementInterface*   sceneObjectManager,
    DataManagementInterface*          dataManager,
    PhysicsDataManagementInterface*   physicsDataManager,
    EuphoriaDataManagementInterface*  euphoriaDataManager,
    PlaybackManagementInterface*      playbackManager,
    PhysicsManipulationInterface*     physicsManipManager) :
    m_connectionManager(connectionManager),
    m_animationBrowser(animationBrowser),
    m_networkManager(networkManager),
    m_networDefkLifecycle(networDefkLifecycle),
    m_networkLifecycle(networkLifecycle),
    m_environmentManager(environmentManager),
    m_sceneObjectManager(sceneObjectManager),
    m_dataManager(dataManager),
    m_physicsDataManager(physicsDataManager),
    m_euphoriaDataManager(euphoriaDataManager),
    m_playbackManager(playbackManager),
    m_physicsManipManager(physicsManipManager)
  {
  }

  ConnectionManagementInterface* getConnectionManager() const { return m_connectionManager; }
  AnimationBrowserInterface* getAnimationBrowser() const { return m_animationBrowser; }
  NetworkManagementInterface* getNetworkManager() const { return m_networkManager; }
  NetworkDefLifecycleInterface* getNetworkDefLifecycle() const { return m_networDefkLifecycle; }
  NetworkLifecycleInterface* getNetworkLifecycle() const { return m_networkLifecycle; }
  EnvironmentManagementInterface* getEnvironmentManager() const { return m_environmentManager; }
  SceneObjectManagementInterface* getSceneObjectManager() const { return m_sceneObjectManager; }
  DataManagementInterface* getDataManager() const { return m_dataManager; }
  PhysicsDataManagementInterface* getPhysicsDataManager() const { return m_physicsDataManager; }
  EuphoriaDataManagementInterface* getEuphoriaDataManager() const { return m_euphoriaDataManager; }
  PlaybackManagementInterface* getPlaybackManager() const { return m_playbackManager; }
  PhysicsManipulationInterface* getPhysicsManipManager() const {return m_physicsManipManager;}
  void broadcastOnConnectionClosed(Connection* connection)
  {
    if (m_connectionManager)
    {
      m_connectionManager->onConnectionClosed(connection);
    }

    if (m_animationBrowser)
    {
      m_animationBrowser->onConnectionClosed(connection);
    }

    if (m_sceneObjectManager)
    {
      m_sceneObjectManager->onConnectionClosed(connection);
    }

    if (m_dataManager)
    {
      m_dataManager->onConnectionClosed(connection);
    }

    // The network life cycle is likely to destroy all network instances associated with the closed connection,
    // therefore we inform it after all other interfaces had a chance to deal with connection data.
    if (m_networkLifecycle)
    {
      m_networkLifecycle->onConnectionClosed(connection);
    }
  }

private:

  ConnectionManagementInterface* const    m_connectionManager;
  AnimationBrowserInterface* const        m_animationBrowser;
  NetworkManagementInterface* const       m_networkManager;
  NetworkDefLifecycleInterface* const     m_networDefkLifecycle;
  NetworkLifecycleInterface* const        m_networkLifecycle;
  EnvironmentManagementInterface* const   m_environmentManager;
  SceneObjectManagementInterface* const   m_sceneObjectManager;
  DataManagementInterface* const          m_dataManager;
  PhysicsDataManagementInterface* const   m_physicsDataManager;
  EuphoriaDataManagementInterface* const  m_euphoriaDataManager;
  PlaybackManagementInterface* const      m_playbackManager;
  PhysicsManipulationInterface* const     m_physicsManipManager; 

  RuntimeTargetInterface(const RuntimeTargetInterface&);
  RuntimeTargetInterface& operator=(const RuntimeTargetInterface&);
};

} // namespace MCOMMS
//----------------------------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------------------------
#endif // MC_RUNTIMETARGETINTERFACE_H
//----------------------------------------------------------------------------------------------------------------------
