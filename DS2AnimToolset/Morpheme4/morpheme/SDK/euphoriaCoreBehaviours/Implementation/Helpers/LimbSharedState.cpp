// Copyright (c) 2013 NaturalMotion.  All Rights Reserved.
// Not to be copied, adapted, modified, used, distributed, sold,
// licensed or commercially exploited in any manner without the
// written consent of NaturalMotion.
//
// All non public elements of this software are the confidential
// information of NaturalMotion and may not be disclosed to any
// person nor used for any purpose not expressly approved by
// NaturalMotion in writing.

#include "LimbSharedState.h"

#ifndef NM_BEHAVIOUR_LIB_NAMESPACE
#error behaviour library namespace undefined
#endif

#include "euphoria/erLimb.h"
#include "euphoria/erBody.h"
#include "euphoria/erGravityCompensation.h"
#include "AutoGenerated/MyNetwork.h"

namespace NM_BEHAVIOUR_LIB_NAMESPACE
{

void LimbSharedState::initialise( ER::Limb& limb)
{
  m_numPartsBeforeBase = limb.getNumPartsBeforeBase();
  m_totalNumParts = limb.getTotalNumParts();
  m_numPartsInChain = limb.getNumPartsInChain();
}

void LimbSharedState::update(
    MyNetwork& myNetwork,
    ER::Limb& limb,
    float timeStep,
    MR::InstanceDebugInterface* MR_OUTPUT_DEBUG_ARG(pDebugDrawInst))
  {
    // Register existence of a contact on any part from base to end.
    m_mainPartIsColliding = false;
    for (int32_t i = m_numPartsBeforeBase; i < m_totalNumParts; i++)
    {
      if (ER::EuphoriaRigPartUserData::getFromPart(limb.getPart(i))->getNumContacts() > 0)
      {
        m_mainPartIsColliding = true;
        break;
      }
    }
    
    // Register existence of contact on any part from root to end (excluding end part itself).
    m_limbBarEndIsColliding = false;
    for (int32_t i = 0; i < m_numPartsInChain - 1; i++)
    {
      if (ER::EuphoriaRigPartUserData::getFromPart(limb.getPart(i))->getNumContacts() > 0)
      {
        m_limbBarEndIsColliding = true;
        break;
      }
    }

    // Store info about contact on the limb end.
    ER::EuphoriaRigPartUserData* endPartUserData =
      ER::EuphoriaRigPartUserData::getFromPart(limb.getPart(limb.getNumPartsInChain() - 1));
    m_endContact.lastVelocity = endPartUserData->getLastAverageVelocity();
    m_endContact.lastPosition = endPartUserData->getLastAveragePosition();
    MR_DEBUG_DRAW_VECTOR(pDebugDrawInst, MR::VT_Velocity,
      m_endContact.lastPosition, m_endContact.lastVelocity, NMP::Colour::BLUE);
    m_endContact.lastNormal = endPartUserData->getLastAverageNormal();
    m_endContact.lastForce = endPartUserData->getLastTotalImpulse() / timeStep;
    m_endContact.inContact = endPartUserData->getNumContacts() != 0;

    // Store root part data (current tm and limbhandledata).
    const MR::PhysicsRig::Part* part = limb.getPart(0);
    m_rootTM = limb.getRootTransform();
    m_rootData.velocity = part->getVelocityAtPoint(m_rootTM.translation());
    m_rootData.angularVelocity = part->getAngVel();
    m_rootData.isCollidingWithWorld 
      = ER::EuphoriaRigPartUserData::getFromPart((MR::PhysicsRig::Part*)part)->getNumContacts() != 0;
    m_rootData.lastCollisionID 
      = ER::EuphoriaRigPartUserData::getFromPart((MR::PhysicsRig::Part*)part)->getLastCollisionID();

    // Store reach limit
    // If below was relative to root transform then we could avoid this multiply 
    // but the cost is minimal, and it's very convenient having the reach limit in world space.
    m_reachLimit = limb.getReachLimit();
    m_reachLimit.m_transform = m_reachLimit.m_transform * part->getTransform(); 

    // Store end part data (limb handle data only), transform update is deferred to subclass which have different 
    // types depending on the sort of limb).
    //
    part = limb.getPart(limb.getNumPartsInChain() - 1);
    NMP::Matrix34 endTM(limb.getEndTransform()); // ** remember this is not quite finished.. because we have removed endTM from the base LimbSharedState class it therefore needs sorting in the subclass updates.
    m_endData.velocity = part->getVelocityAtPoint(endTM.translation());
    m_endData.angularVelocity = part->getAngVel();
    m_endData.isCollidingWithWorld = 
      ER::EuphoriaRigPartUserData::getFromPart((MR::PhysicsRig::Part*)part)->getNumContacts() != 0;
    m_endData.lastCollisionID =
      ER::EuphoriaRigPartUserData::getFromPart((MR::PhysicsRig::Part*)part)->getLastCollisionID();

    // base part data
    part = myNetwork.getCharacter()->getBody().getPhysicsRig()->getPart(limb.getBaseIndex());
    m_basePosition = part->getPosition();

    m_externalSupportAmount = limb.getIsAtAllExternallySupported() ? 1.0f:0.0f;

    // Dynamic state
    m_dynamicState.mass = limb.getMass();
    m_dynamicState.setPosition(limb.getCentreOfMass());
    m_dynamicState.setVelocity(limb.getCOMVelocity());
    m_dynamicState.setAngularVelocity(limb.getCOMAngularVelocity());
    

    // IK error and weights.
    const ER::LimbIK::SolverErrorData sed = limb.getIKSolverErrorData();
    m_IKPositionError = sed.m_positionError;
    m_IKNormalError = sed.m_normalError;
    m_IKOrientationError = sed.m_orientationError;
    m_IKPositionErrorWeight = NMP::clampValue(sed.m_positionErrorWeight, 0.0f, 1.0f);
    m_IKNormalErrorWeight = NMP::clampValue(sed.m_normalErrorWeight, 0.0f, 1.0f);
    m_IKOrientationErrorWeight = NMP::clampValue(sed.m_orientationErrorWeight, 0.0f, 1.0f);

    // Update part tm's
    for (int32_t i = 0; i < m_totalNumParts; ++i)
    {
      m_partTMs[i] = limb.getPart(i)->getTransform();
    }
  }

void HeadLimbSharedState::update(
  MyNetwork& myNetwork,
  ER::Limb& limb,
  float timeStep,
  MR::InstanceDebugInterface* pDebugDrawInst)
{
  // Update common data.
  LimbSharedState::update(myNetwork, limb, timeStep, pDebugDrawInst);
  
  // End locator.
  m_endTM = limb.getEndTransform();
}

void SpineLimbSharedState::update(
  MyNetwork& myNetwork,
  ER::Limb& limb,
  float timeStep,
  MR::InstanceDebugInterface* pDebugDrawInst)
{
  // Update common data.
  LimbSharedState::update(myNetwork, limb, timeStep, pDebugDrawInst);
  
  // End locator.
  m_endTM = limb.getEndTransform();
  
  // Root contact info.
  ER::EuphoriaRigPartUserData* rootData = ER::EuphoriaRigPartUserData::getFromPart(limb.getPart(0));
  m_rootContact.lastVelocity = rootData->getLastAverageVelocity();
  m_rootContact.lastPosition = rootData->getLastAveragePosition();
  MR_DEBUG_DRAW_VECTOR(pDebugDrawInst, MR::VT_Velocity,
    m_rootContact.lastPosition, m_rootContact.lastVelocity, NMP::Colour::BLUE);
  m_rootContact.lastNormal = rootData->getLastAverageNormal();
  m_rootContact.lastForce = rootData->getLastTotalImpulse() / timeStep;
  m_rootContact.inContact = rootData->getNumContacts() != 0;
}

// Only called for spine 0 after all spines have been updated.
void SpineLimbSharedState::updateMainSpineExternalSupportAmount(MyNetwork& myNetwork)
{
  // Override externally supported amount (called only for spine[0]) is determined as follows:
  // - externalSupportAmount = 1.0f, if at least one leg is externally controlled (eg. HK/SK, physics constraint, etc.)
  // - externalSupportAmount = gravity compensation spine root support amount, otherwise 
  //
  bool aLegIsExternallyControlled = false;
  for (uint32_t i = 0; i < myNetwork.data->numLegs; ++i)
  {
    if (myNetwork.data->legLimbSharedStates[i].m_externalSupportAmount > 0.0f)
    {
      aLegIsExternallyControlled = true;
      break;
    }
  }
  if (aLegIsExternallyControlled || m_externalSupportAmount > 0.9999f)
  {
    m_externalSupportAmount = 1.0f;
  }
  else
  {
    m_externalSupportAmount =
      myNetwork.getCharacter()->getBody().m_gravComp->getLimbRootSupported(myNetwork.data->firstSpineRigIndex);
  }
}

void ArmAndLegLimbSharedState::update(
  MyNetwork& myNetwork,
  ER::Limb& limb,
  float timeStep,
  MR::InstanceDebugInterface* pDebugDrawInst)
{
  // Update common data.
  LimbSharedState::update(myNetwork, limb, timeStep, pDebugDrawInst);

  // End locator.
  m_endTM = limb.getEndTransform();

  // Mid limb part position (elbow or knee).
  const MR::PhysicsRig::Part* part;
  part = myNetwork.getCharacter()->getBody().getPhysicsRig()->getPart(limb.getMidIndex());
  m_midLimbPartPosition = part->getPosition();

  // End of limb part position (ankle/wrist).
  part = limb.getPart(limb.getNumPartsInChain() - 1);
  m_endLimbPartPosition = part->getPosition();

  // Constraint
  m_isConstrained = limb.getEndConstraint().isConstrained();
}

//--------------------------------------------------------------------------------------------------
// Calculates the average of a set of values.
//
// Choose closest version of quat since there are two quats per attitude
// Do nothing for other value types.
template<typename T1, typename T2>
NM_INLINE void quatNeg(T1&, const T2&) {}
template<>
NM_INLINE void quatNeg(NMP::Quat& qToTest, const NMP::Quat& q)
{
  if (qToTest.dot(q) < 0.0f)
  {
    qToTest.negate();
  }
}

template <class T>
void average(T& result, const T* values, uint32_t numValues)
{
  NMP_ASSERT(values != 0 && numValues != 0);
  result = values[0];
  uint32_t i = 1;
  for ( ; i < numValues; i++)
  {
    quatNeg(result, values[i]);
    result += values[i];
  }
  result *= 1.0f / i;

}

void BodyLimbSharedState::update(
  MyNetwork& myNetwork,
  const ArmAndLegLimbSharedState* armLimbStates,
  const ArmAndLegLimbSharedState* legLimbStates,
  const HeadLimbSharedState* headLimbStates,
  const SpineLimbSharedState* spineLimbStates)
{
  (void)headLimbStates;
  (void)spineLimbStates;
  //armLimbStates
  //legLimbStates

  // Calc average of end positions
  // Form the array of arm and leg info ({legs}, {arms})
  ER::HandFootTransform legAndArmEndTMs[NetworkConstants::networkMaxNumLegs + NetworkConstants::networkMaxNumArms];
  for(uint32_t i = 0; i < myNetwork.data->numLegs; ++i)
  {
    legAndArmEndTMs[i] = legLimbStates[i].m_endTM;
  }
  for(uint32_t i = 0; i < myNetwork.data->numArms; ++i)
  {
    legAndArmEndTMs[myNetwork.data->numLegs + i] = armLimbStates[i].m_endTM;
  }
  
  if(myNetwork.data->numLegs)
  {
    average(m_averageOfFeetTM, &legAndArmEndTMs[0], myNetwork.data->numLegs);
  }

  if(myNetwork.data->numArms)
  {
    average(m_averageOfHandsTM, &legAndArmEndTMs[myNetwork.data->numLegs], myNetwork.data->numArms);
  }

  if(myNetwork.data->numLegs + myNetwork.data->numArms)
  {
    average(m_averageOfHandsAndFeetTM, &legAndArmEndTMs[0], myNetwork.data->numLegs + myNetwork.data->numArms);
  }

  // Calculate a reference support tm from the default pose feet
  ER::HandFootTransform referenceLegEndTMs[NetworkConstants::networkMaxNumLegs];
  for(uint32_t i = 0; i < myNetwork.data->numLegs; ++i)
  {
    referenceLegEndTMs[i] = myNetwork.data->defaultPoseEndsRelativeToRoot[myNetwork.data->firstLegNetworkIndex + i];
  }

  if(myNetwork.data->numLegs)
  {
    average(m_averageOfDefaultPoseFeetTMWorld, &referenceLegEndTMs[0], myNetwork.data->numLegs);
  }

  // Calculate a reference shoulder frame from the arm reach limit transforms 
  // (retrieve from limb in chest local, and transform to pelvis frame using default chest relative root tm)
  NMP::Matrix34 referenceShoulderTMs[NetworkConstants::networkMaxNumArms];
  for(uint32_t i = 0; i < myNetwork.data->numArms; ++i)
  {
    ER::Body& body = myNetwork.getCharacter()->getBody();

    ER::Limb& armLimb = body.getLimb(body.m_definition->getFirstArmLimbIndex() + i);
    ER::Limb& spineLimb = body.getLimb(body.m_definition->getFirstSpineLimbIndex());
    NMP::Matrix34 chestPartToEndLocatorTM(spineLimb.getDefinition()->m_endOffset);
    chestPartToEndLocatorTM.invert();
    referenceShoulderTMs[i] =
      armLimb.getReachLimit().m_transform
        * chestPartToEndLocatorTM 
          * myNetwork.data->defaultPoseEndsRelativeToRoot[myNetwork.data->firstSpineNetworkIndex];
  }

  if(myNetwork.data->numArms)
  {
    average(m_averageOfDefaultPoseShouldersTMWorld, &referenceShoulderTMs[0], myNetwork.data->numArms);
  }

  // Transform to world space (from coordinates wrt to character root i.e. pelvis).
  m_averageOfDefaultPoseFeetTMWorld = m_averageOfDefaultPoseFeetTMWorld * myNetwork.data->spineLimbSharedStates[0].m_rootTM;
  m_averageOfDefaultPoseShouldersTMWorld = m_averageOfDefaultPoseShouldersTMWorld * myNetwork.data->spineLimbSharedStates[0].m_rootTM;

  float legIKOrientationErrors[NetworkConstants::networkMaxNumLegs];
  for(uint32_t i = 0; i < myNetwork.data->numLegs; ++i)
  {
    legIKOrientationErrors[i] = legLimbStates[i].m_IKOrientationError;
  }

  if(myNetwork.data->numLegs)
  {
    average(m_averageOfLegsIKOrientationError, &legIKOrientationErrors[0], myNetwork.data->numLegs);
  }

  // Dynamic states sum of previously calculated
  m_dynamicState = spineLimbStates[0].m_dynamicState;
  for(uint32_t i = 1; i < myNetwork.data->numSpines; ++i)
  {
    m_dynamicState += spineLimbStates[i].m_dynamicState;
  }
  for(uint32_t i = 0; i < myNetwork.data->numHeads; ++i)
  {
    m_dynamicState += headLimbStates[i].m_dynamicState;
  }
  for(uint32_t i = 0; i < myNetwork.data->numArms; ++i)
  {
    m_dynamicState += armLimbStates[i].m_dynamicState;
  }
  for(uint32_t i = 0; i < myNetwork.data->numLegs; ++i)
  {
    m_dynamicState += legLimbStates[i].m_dynamicState;
  }
}

}