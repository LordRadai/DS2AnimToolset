#pragma once

/*
* Copyright (c) 2011 NaturalMotion Ltd. All rights reserved.
*
* Not to be copied, adapted, modified, used, distributed, sold,
* licensed or commercially exploited in any manner without the
* written consent of NaturalMotion.
*
* All non public elements of this software are the confidential
* information of NaturalMotion and may not be disclosed to any
* person nor used for any purpose not expressly approved by
* NaturalMotion in writing.
*
*/

#ifndef NM_SEQUENCER_H
#define NM_SEQUENCER_H

//----------------------------------------------------------------------------------------------------------------------
#include "Types/ModuleRNG.h"
#include "NMPlatform/NMPlatform.h"
#include "AutoGenerated/NetworkForceInclude.h"

//----------------------------------------------------------------------------------------------------------------------

#ifndef NM_BEHAVIOUR_LIB_NAMESPACE
  #error behaviour library namespace undefined
#endif

namespace NM_BEHAVIOUR_LIB_NAMESPACE
{
//----------------------------------------------------------------------------------------------------------------------
//
// A container that marshals the details of sequencing and indexing a set of "items" some or
// all of which may be activated or deactivated on a frame by frame basis.
// Currently used for sequencing arm reaching and still a little specific to that.
// Parametrised on the size of the set of things to be sequenced, but could at some
// point be generalised further on the type of "Item"
//
// holds an array of sequence info upto a given maximum size (N)
// together with an array of bool of exactly that size to
// signal which if any of the sequenceable things are currently "active"
//
template<size_t N>
struct Sequencer
{
  // an array of these is used to create a sequence each item "begins" when timeStart == currTime
  struct Item
  {
    uint32_t sourceIndex; // the original index (eg. armId)
    float timeStart;
    float d; // distance/error for monitoring and/or as sequencing criterion
  };

  Sequencer();
  void setup(const float* dist, const bool* currActive, uint32_t n);
  void orderDistanceDecreasing(float currTime, float pause = 5.0f / 60.0f, float pauseTol = 3.0f / 60.0f);
  void synchronise(
    float currTime, const float* dist, const bool* activeCurr, uint32_t n,
    float pause = 5.0f / 60.0f, float pauseTol = 3.0f / 60.0f);
  void shuffle();

  // the maximum number of things we can sequence with this sequencer
  static const uint32_t capacity = N;
  Item items[capacity];   // the sequenced (currently active) subset
  bool active[capacity];  // the map from the sequenceable things to active sequenceable things
  uint32_t size;          // the current number of active items

  ModuleRNG rng;
};

//----------------------------------------------------------------------------------------------------------------------
// Sequencer defs

template<size_t N>
Sequencer<N>::Sequencer() : size(0) {}

// populates the sequence with details of active items
// those that are inactive are ignored and remain uncounted
// active/inactive is signalled by the array of bool "currActive"
// a copy of currActive is cached for future reference (see synchronise())
//
template<size_t N>
void Sequencer<N>::setup(const float* dist, const bool* currActive, uint32_t n)
{
  NMP_ASSERT(n == capacity);

  size = 0;
  for (uint32_t i = 0; i < n; ++i)
  {
    active[i] = currActive[i];
    if (active[i])
    {
      items[size].sourceIndex = i;
      items[size].timeStart = 0.0f;
      items[size].d = dist[i];
      ++size;
    }
  }
}

// sets up a sequence of frame start values separated by a a minimum wait time (pause) and
// a random jitter (pauseTol)
// then assigns a framestart value to each item in the sequence in order of decreasing d
//
template<size_t N>
void Sequencer<N>::orderDistanceDecreasing(float currTime, float pause, float pauseTol)
{
  // set a sequence of frame starts increasing in index order (i.e. i < j <==> items[i].timeStart < items[j].tiameStart)
  float timeStart = currTime + pauseTol;
  for (uint32_t i = 0; i < size; ++i)
  {
    items[i].timeStart = timeStart;
    timeStart += pause + (rng.genFloat(0.0f, pauseTol)); // next reach frame start
  }

  // sort start frames by d
  for (uint32_t i = 0; i < size; ++i)
  {
    for (uint32_t j = i; j < size - 1; ++j)
    {
      if (items[j].d < items[j+1].d)
        NMP::nmSwap(items[j].timeStart, items[j+1].timeStart);
    }
  }
}

// synchronise the current sequence taking into account any changes in
// the active map
// all active get distance updated
// newly activated get a new framestart (join the sequence)
// already active retain framestarts untouched
// previously but no longer active are dropped
//
template<size_t N>
void Sequencer<N>::synchronise(
  float currTime, const float* dist, const bool* activeCurr, uint32_t n,
  float pause, float pauseTol)
{
  // cache sequence items from previous frame (needed for their
  // framestart values)
  Item prevRS[capacity];
  float maxTimeStart = currTime;
  for (uint32_t i = 0; i < size; ++i)
  {
    prevRS[i] = items[i];
    maxTimeStart = NMP::maximum(maxTimeStart, items[i].timeStart);
  }
  // next frame start needs a pause interval if the last has still
  // not been reached otherwise can start immediately
  if (maxTimeStart > currTime)
    maxTimeStart += pause + rng.genFloat(0.0f, pauseTol);

  // remake the sequence updating distance to effector values,
  // preserving existing ordering and splicing in newly activate limbs
  //
  // setup main, previous and current sequence counters for loop
  uint32_t i = 0, r = 0, s = 0;
  for (; i < n; ++i)
  {
    //if (!active[i] && !activeCurr[i]) only i to increment
    if (active[i] && !activeCurr[i])
    {
      // do nothing except increment r
      ++r;
    }
    else if (!active[i] && activeCurr[i])
    {
      // write then increment curr counter
      items[s].sourceIndex = i;
      items[s].d = dist[i];
      items[s].timeStart = maxTimeStart;
      maxTimeStart += pause + rng.genFloat(0.0f, pauseTol);
      ++s;
    }
    else if (active[i] && activeCurr[i])
    {
      // write then increment both prev and curr counters
      items[s].sourceIndex = i;
      items[s].d = dist[i];
      items[s].timeStart = prevRS[r].timeStart;
      ++r, ++s;
    }
    // copy the active map as we go
    active[i] = activeCurr[i];
  }
  size = s;
}

// randomly shuffle frame start values
//
template<size_t N>
void Sequencer<N>::shuffle()
{
  for (uint32_t i = 0; i < size; ++i)
  {
    NMP::nmSwap(items[i].timeStart, items[rng.genUInt32() % size].timeStart);
  }
}

//----------------------------------------------------------------------------------------------------------------------
}

#endif //NM_SEQUENCER_H
