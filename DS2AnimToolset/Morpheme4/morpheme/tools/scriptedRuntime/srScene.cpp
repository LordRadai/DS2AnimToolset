// Copyright (c) 2013 NaturalMotion.  All Rights Reserved.
// Not to be copied, adapted, modified, used, distributed, sold,
// licensed or commercially exploited in any manner without the
// written consent of NaturalMotion.  
//
// All non public elements of this software are the confidential
// information of NaturalMotion and may not be disclosed to any
// person nor used for any purpose not expressly approved by
// NaturalMotion in writing.

// ---------------------------------------------------------------------------------------------------------------------
#include "scriptedRuntimeApp.h"

#include "srScene.h"
#include "srEnvironment.h"
#include "srNetwork.h"

#include "morpheme/mrInstanceDebugInterface.h"

#include "physics/mrPhysics.h"
#include "physics/PhysX3/mrPhysX3.h"
#include "physics/PhysX3/mrPhysicsRigPhysX3Articulation.h"
#include "physics/PhysX3/mrPhysX3Includes.h"
#include "physics/PhysX3/mrPhysX3Deprecated.h"
#include "physics/mrPhysicsSerialisationBuffer.h"

#include "euphoria/erEuphoriaUserData.h"
#include "AutoGenerated/MyNetwork.h"
#include "AutoGenerated/Arm.h"
#include "AutoGenerated/Head.h"
#include "AutoGenerated/HeadEyes.h"
#include "AutoGenerated/BodyBalance.h"

#include "NMPlatform/NMLoggingMemoryAllocator.h"

#include "AutoGenerated/BehaviourInterfaces.h"

// Disable warning on "conditional expression is constant" for templated functions with bool template arg.
#pragma warning(disable : 4127)

extern void SqErrFunc(const SQChar *s, ...);

static MR::MorphemePhysX3ContactModifyCallback morphemePhysX3ContactModifyCallback(1.0f, 1/30.0f);

static bool g_isLogOutputEnabled = true;

// ---------------------------------------------------------------------------------------------------------------------
namespace ScriptWrappers 
{ 
  struct SqNetworkDef;
  struct SqPhysXActor;
}

// ---------------------------------------------------------------------------------------------------------------------
class PhysicsAPI
{
public:

  NM_INLINE void setScene(MR::PhysicsScenePhysX3* scene) { m_scene = scene; }

  bool connectPhysXDebugger();

  template <bool isDynamic>
  ScriptWrappers::SqPhysXActor* createBox(
    const NMP::Vector3 &pos, 
    const NMP::Vector3 &dims, 
    const NMP::Quat &rot,
    float friction, 
    float restitution,
    float density);

  template <bool isDynamic>
  ScriptWrappers::SqPhysXActor* createSphere(
    const NMP::Vector3 &pos, 
    float radius,
    const NMP::Quat &rot,
    float friction, 
    float restitution,
    float density);

  template <bool isDynamic>
  ScriptWrappers::SqPhysXActor* createCapsule(
    const NMP::Vector3 &pos, 
    float radius,
    float halfHeight,
    const NMP::Quat &rot,
    float friction, 
    float restitution,
    float density);

protected:

  MR::PhysicsScenePhysX3      *m_scene;
};

// ---------------------------------------------------------------------------------------------------------------------
class SceneData
{
public:

  void init(const class Environment* env);

  NM_INLINE void registerForScripting(sqp::SquirrelVM& vm);


  struct NetworkState
  {
    NetworkState() :
      m_network(0),
      m_euphoriaRootModule(0),
      m_needUpdate(false),
      m_networkInstFootprint(0)
    {
      memset(m_traceBufferPrePhys, 0, eMaxPathLengthForTrace);
      memset(m_traceBufferPostPhys, 0, eMaxPathLengthForTrace);
    }

    void updateNetworkStart(float step);
    void updateNetworkPreController(float step);
    void updateNetworkPostController(float step);
    void updateNetworkPrePhysics(float step);
    void updateNetworkPostPhysics(float step);
    void updateNetworkRoot(float step);

    MR::Network            *m_network;
    ER::RootModule         *m_euphoriaRootModule;
    bool                    m_needUpdate;
    size_t                  m_networkInstFootprint;

    enum { eMaxPathLengthForTrace = 160 };
    char                    m_traceBufferPrePhys[eMaxPathLengthForTrace],
                            m_traceBufferPostPhys[eMaxPathLengthForTrace];
  };

  typedef std::vector<NetworkState*> NetworkStates;
  typedef std::vector<ScriptWrappers::SqNetworkDef*> NetworkDefs;


protected:

  void setCurrentDirectory(const char* dir);

  ScriptWrappers::SqNetworkDef* loadNetworkDef(const char* networkName);

  ScriptWrappers::SqNetworkDef* loadDefaultNetworkDef();

  void updateAll(float step);

  PhysicsAPI* getPhysicsAPI() { return &m_physicsAPI; }

  void submitMemoryUsage(Environment* env);


  NetworkStates               m_networkStates;
  NetworkDefs                 m_networkDefs;

  PhysicsAPI                  m_physicsAPI;
  MR::PhysicsScenePhysX3     *m_physicsScene;
  const Environment          *m_env;

private:
  void doUpdate(float step);
};


// ---------------------------------------------------------------------------------------------------------------------
namespace ScriptWrappers
{

// ---------------------------------------------------------------------------------------------------------------------
struct SqNetworkInstance
{
  SqNetworkInstance() :
    m_state(0)
  {
    // Initialise the savedState to a sensible size
    static const int stateSize = 1024 * 256;
    m_savedState.dataStart = new char[stateSize];
    m_savedState.ptr = m_savedState.dataStart;
    m_savedState.space = stateSize;
    memset(m_savedState.ptr, 0, stateSize);
  }

  // set a control parameter into the network.
  bool setFloatControlParameter(const char* CPName, const float CPFloat);
  
  // set a control parameter into the network.
  bool setVectorControlParameter(const char* CPName, const NMP::Vector3& CPVec);
  
  // send a message into the network
  bool broadcastMessage(const char* messageName);

  void addImpulseToChar(const NMP::Vector3& f);
  void addTorqueImpulseToChar(const NMP::Vector3& t);
  NMP::Vector3 getRootCharPosition();
  NMP::Vector3 getRootCharVelocity();
  NMP::Vector3 getHeadPosition();
  NMP::Vector3 getLeftHandPosition();
  NMP::Vector3 getRightHandPosition();
  NMP::Matrix34 getLeftHandTM();
  NMP::Matrix34 getRightHandTM();
  NMP::Vector3 getLookPosition();
  float getTimeSinceLastStep();
  void setCharVelocity(const NMP::Vector3& vel);
  void translateChar(const NMP::Vector3& translation);
  void rotateChar(const NMP::Vector3& rot); // rotate around the root position
  void setCharControllerTransform(const NMP::Matrix34& tm);
  int getNumConstrainedArms();
  bool isBalanced();
  bool isInFreefall();
  bool isShielding();
  bool hasHeadCollided();
  bool hasChestCollided();
  void storeState();
  void restoreState();
  void disableBehaviourEffects();

  std::string                 m_name;
  SceneData::NetworkState    *m_state;
  MR::PhysicsSerialisationBuffer m_savedState;
};

// ---------------------------------------------------------------------------------------------------------------------
struct SqNetworkDef
{
  SqNetworkInstance* createInstance(const char* instName, const NMP::Matrix34& initialTM);

  std::string                   m_name;
  MR::PhysicsScenePhysX3       *m_physicsScene;
  SceneData::NetworkStates     *m_networkStates;
  MR::NetworkDef               *m_def;
  MR::InstanceDebugInterface   *m_debugInterface;
  NMP::LoggingMemoryAllocator  *m_persistAllocator;
  size_t                        m_defDataFootprint;
};

// ---------------------------------------------------------------------------------------------------------------------
struct SqPhysXActor
{
  physx::PxActor           *m_actor;

  void addImpulse(const NMP::Vector3& f);
  void addAngularImpulse(const NMP::Vector3& ap);
  void addImpulseAtPos(const NMP::Vector3& f, const NMP::Vector3& pt);
  void addLocalImpulseAtPos(const NMP::Vector3& f, const NMP::Vector3& pt);
  void addLocalImpulseAtLocalPos(const NMP::Vector3& f, const NMP::Vector3& pt);

  void addForce(const NMP::Vector3& f);
  void addForceAtPos(const NMP::Vector3& f, const NMP::Vector3& pt);
  void addLocalForce(const NMP::Vector3& f);
  void addLocalForceAtPos(const NMP::Vector3& f, const NMP::Vector3& pt);

  void addTorque(const NMP::Vector3& t);

  float getMass() { return m_actor->isRigidBody()->getMass(); }

  void setVelocity(const NMP::Vector3& vel);

  NMP::Matrix34 getGlobalTransform();
  void setPosition(const NMP::Vector3& position);
};

} // namespace ScriptWrappers



// ---------------------------------------------------------------------------------------------------------------------
Scene::Scene() :
  m_data(new SceneData)
{

}

// ---------------------------------------------------------------------------------------------------------------------
Scene::~Scene()
{
  delete m_data;
}

// ---------------------------------------------------------------------------------------------------------------------
void Scene::init(const class Environment* env)
{
  m_data->init(env);
}

// ---------------------------------------------------------------------------------------------------------------------
void Scene::registerForScripting(sqp::SquirrelVM& vm)
{
  m_data->registerForScripting(vm);
}

// ---------------------------------------------------------------------------------------------------------------------
class ErrorStream : public physx::PxErrorCallback
{
public:
  void reportError(physx::PxErrorCode::Enum e, const char* message, const char* file, int line)
  {
    printf("%s (%d) :", file, line);
    switch (e)
    {
    case physx::PxErrorCode::eINVALID_PARAMETER:
      printf( "invalid parameter");
      break;
    case physx::PxErrorCode::eINVALID_OPERATION:
      printf( "invalid operation");
      break;
    case physx::PxErrorCode::eOUT_OF_MEMORY:
      printf( "out of memory");
      break;
    case physx::PxErrorCode::eDEBUG_INFO:
      printf( "info");
      break;
    case physx::PxErrorCode::eDEBUG_WARNING:
      printf( "warning");
      break;
    default:
      printf("unknown error");
    }

    printf(" : %s\n", message);
  }

  void print(const char* message)
  {
    printf(message);
  }
};

ErrorStream g_physXErrorCallback;

class AllocatorCallback : public physx::PxAllocatorCallback
{
#ifdef WIN32
  // on win32 we only have 8-byte alignment guaranteed, but the CRT provides special aligned
  // allocation fns
  void* allocate(size_t size, const char*, const char*, int)
  {
    return _aligned_malloc(size, 16);
  }
  void deallocate(void* ptr)
  {
    _aligned_free(ptr);
  }
#else
  // on PS3, XBox and Win64 we get 16-byte alignment by default
  void* allocate(size_t size, const char*, const char*, int)
  {
    void *ptr = ::malloc(size);
    PX_ASSERT((reinterpret_cast<size_t>(ptr) & 15)==0);
    return ptr;
  }
  void deallocate(void* ptr)
  {
    ::free(ptr);
  }
#endif
};

AllocatorCallback g_physXAllocator;

// ---------------------------------------------------------------------------------------------------------------------
void SceneData::init(const Environment* env)
{
  m_env = env;

  // Allow functions to find out of logging is enabled
  g_isLogOutputEnabled = env->isLogOutputEnabled();

  initMorphemeAndEuphoria();
  physx::PxTolerancesScale scale;

  physx::PxFoundation* foundation = PxCreateFoundation(PX_PHYSICS_VERSION,  g_physXAllocator, g_physXErrorCallback);
  NMP_ASSERT(foundation);

  physx::PxPhysics* physics = PxCreatePhysics(PX_PHYSICS_VERSION, *foundation, scale);
  NMP_ASSERT(physics);

  if (!physics)
  {
    printf(
      "Unable to create the NVIDIA PhysX SDK. "
      "The NVIDIA PhysX System software is required to run this app.");
    NMP_ASSERT_FAIL();
  }

  physx::PxCookingParams cookingParams;
  cookingParams.skinWidth = 0.01f; // Copied from earlier, should we use physX default here?
#if defined(NM_HOST_WIN32) || defined(NM_HOST_WIN64)
  cookingParams.targetPlatform = physx::PxPlatform::ePC;
#elif defined(NM_HOST_X360)
  cookingParams.targetPlatform = physx::PxPlatform::eXENON; 
#elif defined(NM_HOST_CELL_PPU)
  cookingParams.targetPlatform = physx::PxPlatform::ePLAYSTATION3;
#endif
  PxCreateCooking(PX_PHYSICS_VERSION, *foundation, cookingParams);
  
  PxInitExtensions(PxGetPhysics());

  // create new physics scene
  physx::PxSceneDesc sceneDesc(PxGetPhysics().getTolerancesScale());
  sceneDesc.filterShader = MR::morphemePhysX3FilterShader;
  sceneDesc.contactModifyCallback = &morphemePhysX3ContactModifyCallback;
  sceneDesc.gravity      = physx::PxVec3(0, -9.81f, 0);

  physx::pxtask::CpuDispatcher *cpuDispatcher = physx::PxDefaultCpuDispatcherCreate(1);
  sceneDesc.cpuDispatcher = cpuDispatcher;

  physx::PxScene* scene = PxGetPhysics().createScene(sceneDesc);
  void* alignedMemory = NMP::Memory::memAllocAligned(sizeof(MR::PhysicsScenePhysX3), NMP_VECTOR_ALIGNMENT);
  m_physicsScene = new(alignedMemory) MR::PhysicsScenePhysX3(scene);

  scene->setClientBehaviorBits(0, 15); // All the basic bits set for now, see PxClientBehaviorBit
  m_physicsScene->setPhysXScene(scene);

  // Add API to script the physics scene
  m_physicsAPI.setScene(m_physicsScene);

  // Connect the PhysX debugger, if available
  m_physicsAPI.connectPhysXDebugger();
}

// ---------------------------------------------------------------------------------------------------------------------
void SceneData::setCurrentDirectory(const char* dir)
{
  if (g_isLogOutputEnabled)
    NMP_MSG("Changing directory to '%s' ...", dir);

  ::setCurrentDirectory(dir);
}

// ---------------------------------------------------------------------------------------------------------------------
ScriptWrappers::SqNetworkDef* SceneData::loadDefaultNetworkDef()
{
  return loadNetworkDef(m_env->getDefaultNetwork());
}

// ---------------------------------------------------------------------------------------------------------------------
ScriptWrappers::SqNetworkDef* SceneData::loadNetworkDef(const char* networkName)
{
  if (g_isLogOutputEnabled)
    NMP_MSG("Loading Network '%s'", networkName);

  ScriptWrappers::SqNetworkDef *newDef = new ScriptWrappers::SqNetworkDef;
  newDef->m_name = networkName;
  newDef->m_physicsScene = m_physicsScene;
  newDef->m_networkStates = &m_networkStates;
  newDef->m_def = Network::loadDefinition(networkName, newDef->m_defDataFootprint);
  NMP_ASSERT(newDef->m_def);

  // failed to load?
  if (newDef->m_def == 0)
  {
    NMP_MSG("Network failed to load!");
    return 0;
  }

  NMP::Memory::Format logAllocAllocatorFormat = NMP::LoggingMemoryAllocator::getMemoryRequirements();
  NMP::Memory::Resource logAllocResource = NMPMemoryAllocateFromFormat(logAllocAllocatorFormat);
  NMP_ASSERT(logAllocResource.ptr);
  newDef->m_persistAllocator = NMP::LoggingMemoryAllocator::init(logAllocResource);

  m_networkDefs.push_back(newDef);

  return newDef;
}

// ---------------------------------------------------------------------------------------------------------------------
void SceneData::updateAll(float step)
{
#if (defined(NM_HOST_WIN32) || defined(NM_HOST_WIN64)) && !defined(_DEBUG)
  __try
  {
#endif // NM_HOST_WIN32/64

  m_physicsScene->setNextPhysicsTimeStep(step);

  doUpdate(step);

#if (defined(NM_HOST_WIN32) || defined(NM_HOST_WIN64)) && !defined(_DEBUG)
  // on Windows we try and catch any disastrous problems and just bail out immediately
  }
  __except(EXCEPTION_EXECUTE_HANDLER)
  {
    printf("Exception caught during scene update : terminating app!\n");
    exit(-1);
  }
#endif // NM_HOST_WIN32/64

}

// ---------------------------------------------------------------------------------------------------------------------
void SceneData::doUpdate(float step)
{
  NM_BEGIN_PROFILING("Whole_Frame");
  {
    // -- pre physics step --
    for (size_t i=0; i<m_networkStates.size(); i++)
    {
      NetworkState *networkState = m_networkStates[i];

      networkState->updateNetworkStart(step);
      networkState->updateNetworkPreController(step);
      networkState->updateNetworkPostController(step);
      networkState->updateNetworkPrePhysics(step);
    }

    // -- physics step --
    {
      NM_BEGIN_PROFILING("Update_Physics");
      float maxSeparationSpeed = 0.5f;
      morphemePhysX3ContactModifyCallback.setTimeStep(step);
      morphemePhysX3ContactModifyCallback.setMaxSeparationSpeed(maxSeparationSpeed);

      m_physicsScene->getPhysXScene()->simulate(step);
      m_physicsScene->getPhysXScene()->fetchResults(true);
      m_physicsScene->setLastPhysicsTimeStep(step);
      NM_END_PROFILING();
    }

    // -- post physics step --
    for (size_t i=0; i<m_networkStates.size(); i++)
    {
      NetworkState *networkState = m_networkStates[i];

      networkState->updateNetworkPostPhysics(step);
      networkState->updateNetworkRoot(step);
    }
  }
  NM_END_PROFILING();
}

//----------------------------------------------------------------------------------------------------------------------
// PhysicsAPI
//----------------------------------------------------------------------------------------------------------------------
bool PhysicsAPI::connectPhysXDebugger()
{
  physx::PxPhysics& physics = PxGetPhysics();
  if (physics.getPvdConnectionManager() != 0)
  {
    // Create a pvd connection that writes data straight to the filesystem.  This is
    // the fastest connection on windows for various reasons.  First, the transport is quite fast as
    // pvd writes data in blocks and filesystems work well with that abstraction.
    // Second, you don't have the PVD application parsing data and using CPU and memory bandwidth
    // while your application is running.
    // return mSDK->getPvdConnectionManager()->connect("c:\\temp.pxd2", true, theConnectionFlags);

    // The normal way to connect to pvd.  PVD needs to be running at the time this function is called.
    // We don't worry about the return value because we are already registered as a listener for connections
    // and thus our onPvdConnected call will take care of setting up our basic connection state.
    physx::PxVisualDebuggerExt::createConnection(
      PxGetPhysics().getPvdConnectionManager(), 
      "127.0.0.1", 5425, 10, 
      physx::PxVisualDebuggerConnectionFlags(
      physx::PxVisualDebuggerConnectionFlag::Debug | 
      physx::PxVisualDebuggerConnectionFlag::Profile | 
      physx::PxVisualDebuggerConnectionFlag::Memory ));

    if (physics.getVisualDebugger())
    {
      physics.getVisualDebugger()->setVisualDebuggerFlag(physx::PxVisualDebuggerFlags::eTRANSMIT_CONTACTS, true);
      return true;
    }
    return false;
  }

  // Already connected
  return true;
}

//----------------------------------------------------------------------------------------------------------------------
template <bool isDynamic>
ScriptWrappers::SqPhysXActor* PhysicsAPI::createBox(
  const NMP::Vector3 &pos,
  const NMP::Vector3 &dims,
  const NMP::Quat &rot,
  float friction, 
  float restitution,
  float density)
{
  ScriptWrappers::SqPhysXActor* scriptActor = new ScriptWrappers::SqPhysXActor;
  physx::PxBoxGeometry box;
  box.halfExtents = physx::PxVec3(dims.x, dims.y, dims.z);

  PxShapeDesc boxShapeDesc(PxGetPhysics().getTolerancesScale());
  boxShapeDesc.localPose.p = physx::PxVec3(0, 0, 0);
  NMP::Vector3 r = rot.toRotationVector();
  float angle = r.normaliseGetLength();
  boxShapeDesc.localPose.q = physx::PxQuat(angle, physx::PxVec3(r.x, r.y, r.z));
  boxShapeDesc.contactOffset = 0.0001f; // Default value from sandpit.
  boxShapeDesc.restOffset = 0.0f; // Default value from sandpit.
  boxShapeDesc.geometry = &box;

  physx::PxPhysics* physics = &PxGetPhysics();
  physx::PxMaterial* boxMaterial = physics->createMaterial(friction, friction, restitution);
  boxMaterial->setFrictionCombineMode(physx::PxCombineMode::eMULTIPLY);
  boxMaterial->setRestitutionCombineMode(physx::PxCombineMode::eMULTIPLY);
  boxShapeDesc.setSingleMaterial(boxMaterial);

  physx::PxFilterData filterData;
  if (isDynamic)
  {
    filterData.word0 = 1<<MR::GROUP_COLLIDABLE_PUSHABLE;
    boxShapeDesc.simulationFilterData = filterData;
    boxShapeDesc.queryFilterData = filterData;

    PxRigidDynamicDesc boxDesc(PxGetPhysics().getTolerancesScale());
    boxDesc.clientBehaviorBits = m_scene->getPhysXScene()->getClientBehaviorBits(physx::PX_DEFAULT_CLIENT);
    boxDesc.ownerClient = physx::PX_DEFAULT_CLIENT;
    boxDesc.setSingleShape(boxShapeDesc);
    boxDesc.globalPose.p = physx::PxVec3(pos.x, pos.y, pos.z);
    boxDesc.globalPose.q = physx::PxQuat::createIdentity();
    boxDesc.maxAngularVelocity = 15.0f;
    boxDesc.sleepEnergyThreshold = 0.005f;
    NMP_ASSERT(boxDesc.isValid());
    scriptActor->m_actor = PxCreateRigidDynamic(boxDesc);
    NMP_ASSERT(scriptActor->m_actor);
    physx::PxRigidBodyExt::updateMassAndInertia(*scriptActor->m_actor->isRigidDynamic(), density);
  }
  else
  {
    filterData.word0 = 1<<MR::GROUP_COLLIDABLE_NON_PUSHABLE;
      boxShapeDesc.simulationFilterData = filterData;
    boxShapeDesc.queryFilterData = filterData;
    PxRigidStaticDesc boxDesc(PxGetPhysics().getTolerancesScale());
    boxDesc.clientBehaviorBits = m_scene->getPhysXScene()->getClientBehaviorBits(physx::PX_DEFAULT_CLIENT);
    boxDesc.ownerClient = physx::PX_DEFAULT_CLIENT;
    boxDesc.setSingleShape(boxShapeDesc);
    boxDesc.globalPose.p = physx::PxVec3(pos.x, pos.y, pos.z);
    boxDesc.globalPose.q = physx::PxQuat::createIdentity();
    NMP_ASSERT(boxDesc.isValid());
    scriptActor->m_actor = PxCreateRigidStatic(boxDesc);
    NMP_ASSERT(scriptActor->m_actor);
  }

  physx::PxShape *tempShapes[1];
  scriptActor->m_actor->isRigidActor()->getShapes(&tempShapes[0], 1);
  MR::PhysXPerShapeData::create(tempShapes[0]);

  m_scene->getPhysXScene()->addActor(*scriptActor->m_actor);

  return scriptActor;
}

// ---------------------------------------------------------------------------------------------------------------------
template <bool isDynamic>
ScriptWrappers::SqPhysXActor* PhysicsAPI::createSphere(
  const NMP::Vector3 &pos, 
  float radius,
  const NMP::Quat &rot,
  float friction, 
  float restitution,
  float density)
{
  ScriptWrappers::SqPhysXActor* scriptActor = new ScriptWrappers::SqPhysXActor;
  physx::PxSphereGeometry sphere;
  sphere.radius = radius;

  PxShapeDesc sphereShapeDesc(PxGetPhysics().getTolerancesScale());
  sphereShapeDesc.localPose.p = physx::PxVec3(0, 0, 0);
  NMP::Vector3 r = rot.toRotationVector();
  float angle = r.normaliseGetLength();
  sphereShapeDesc.localPose.q = physx::PxQuat(angle, physx::PxVec3(r.x, r.y, r.z));
  sphereShapeDesc.contactOffset = 0.0001f;
  sphereShapeDesc.restOffset = 0.0f;
  sphereShapeDesc.geometry = &sphere;

  physx::PxPhysics* physics = &PxGetPhysics();
  physx::PxMaterial* sphereMaterial = physics->createMaterial(friction, friction, restitution);
  sphereMaterial->setFrictionCombineMode(physx::PxCombineMode::eMULTIPLY);
  sphereMaterial->setRestitutionCombineMode(physx::PxCombineMode::eMULTIPLY);
  sphereShapeDesc.setSingleMaterial(sphereMaterial);


  physx::PxFilterData filterData;
  if (isDynamic)
  {
    filterData.word0 = 1<<MR::GROUP_COLLIDABLE_PUSHABLE;
    sphereShapeDesc.simulationFilterData = filterData;
    sphereShapeDesc.queryFilterData = filterData;

    PxRigidDynamicDesc sphereDesc(PxGetPhysics().getTolerancesScale());
    sphereDesc.clientBehaviorBits = m_scene->getPhysXScene()->getClientBehaviorBits(physx::PX_DEFAULT_CLIENT);
    sphereDesc.ownerClient = physx::PX_DEFAULT_CLIENT;
    sphereDesc.setSingleShape(sphereShapeDesc);
    sphereDesc.globalPose.p = physx::PxVec3(pos.x, pos.y, pos.z);
    sphereDesc.maxAngularVelocity = 15.0f;
    sphereDesc.sleepEnergyThreshold = 0.005f;
    NMP_ASSERT(sphereDesc.isValid());
    scriptActor->m_actor = PxCreateRigidDynamic(sphereDesc);
    NMP_ASSERT(scriptActor->m_actor);
    physx::PxRigidBodyExt::updateMassAndInertia(*scriptActor->m_actor->isRigidDynamic(), density);
  }
  else
  {
    filterData.word0 = 1<<MR::GROUP_COLLIDABLE_NON_PUSHABLE;
    sphereShapeDesc.simulationFilterData = filterData;
    sphereShapeDesc.queryFilterData = filterData;
    PxRigidStaticDesc sphereDesc(PxGetPhysics().getTolerancesScale());
    sphereDesc.clientBehaviorBits = m_scene->getPhysXScene()->getClientBehaviorBits(physx::PX_DEFAULT_CLIENT);
    sphereDesc.ownerClient = physx::PX_DEFAULT_CLIENT;
    sphereDesc.setSingleShape(sphereShapeDesc);
    sphereDesc.globalPose.p = physx::PxVec3(pos.x, pos.y, pos.z);
    NMP_ASSERT(sphereDesc.isValid());
    scriptActor->m_actor = PxCreateRigidStatic(sphereDesc);
    NMP_ASSERT(scriptActor->m_actor);
  }

  physx::PxShape *tempShapes[1];
  scriptActor->m_actor->isRigidBody()->getShapes(&tempShapes[0], 1);
  MR::PhysXPerShapeData::create(tempShapes[0]);

  m_scene->getPhysXScene()->addActor(*scriptActor->m_actor);

  return scriptActor;
  
}

// ---------------------------------------------------------------------------------------------------------------------
template <bool isDynamic>
ScriptWrappers::SqPhysXActor* PhysicsAPI::createCapsule(
  const NMP::Vector3 &pos, 
  float radius,
  float halfHeight,
  const NMP::Quat &rot,
  float friction, 
  float restitution,
  float density)
{
  ScriptWrappers::SqPhysXActor* scriptActor = new ScriptWrappers::SqPhysXActor;
  physx::PxCapsuleGeometry capsule;
  capsule.radius = radius;
  capsule.halfHeight = halfHeight;
  
  PxShapeDesc capsuleShapeDesc(PxGetPhysics().getTolerancesScale());
  capsuleShapeDesc.localPose.p = physx::PxVec3(0, 0, 0);
  NMP::Vector3 r = rot.toRotationVector();
  float angle = r.normaliseGetLength();
  capsuleShapeDesc.localPose.q = physx::PxQuat(angle, physx::PxVec3(r.x, r.y, r.z));
  capsuleShapeDesc.contactOffset = 0.0001f;
  capsuleShapeDesc.restOffset = 0.0f;
  capsuleShapeDesc.geometry = & capsule;

  physx::PxPhysics* physics = &PxGetPhysics();
  physx::PxMaterial* capsuleMaterial = physics->createMaterial(friction, friction, restitution);
  capsuleMaterial->setFrictionCombineMode(physx::PxCombineMode::eMULTIPLY);
  capsuleMaterial->setRestitutionCombineMode(physx::PxCombineMode::eMULTIPLY);
  capsuleShapeDesc.setSingleMaterial(capsuleMaterial);


  physx::PxFilterData filterData;
  if (isDynamic)
  {
    filterData.word0 = 1<<MR::GROUP_COLLIDABLE_PUSHABLE;
    capsuleShapeDesc.simulationFilterData = filterData;
    capsuleShapeDesc.queryFilterData = filterData;

    PxRigidDynamicDesc sphereDesc(PxGetPhysics().getTolerancesScale());
    sphereDesc.clientBehaviorBits = m_scene->getPhysXScene()->getClientBehaviorBits(physx::PX_DEFAULT_CLIENT);
    sphereDesc.ownerClient = physx::PX_DEFAULT_CLIENT;
    sphereDesc.setSingleShape(capsuleShapeDesc);
    sphereDesc.globalPose.p = physx::PxVec3(pos.x, pos.y, pos.z);
    sphereDesc.maxAngularVelocity = 15.0f;
    sphereDesc.sleepEnergyThreshold = 0.005f;
    NMP_ASSERT(sphereDesc.isValid());
    scriptActor->m_actor = PxCreateRigidDynamic(sphereDesc);
    NMP_ASSERT(scriptActor->m_actor);
    physx::PxRigidBodyExt::updateMassAndInertia(*scriptActor->m_actor->isRigidDynamic(), density);
  }
  else
  {
    filterData.word0 = 1<<MR::GROUP_COLLIDABLE_NON_PUSHABLE;
    capsuleShapeDesc.simulationFilterData = filterData;
    capsuleShapeDesc.queryFilterData = filterData;
    PxRigidStaticDesc sphereDesc(PxGetPhysics().getTolerancesScale());
    sphereDesc.clientBehaviorBits = m_scene->getPhysXScene()->getClientBehaviorBits(physx::PX_DEFAULT_CLIENT);
    sphereDesc.ownerClient = physx::PX_DEFAULT_CLIENT;
    sphereDesc.setSingleShape(capsuleShapeDesc);
    sphereDesc.globalPose.p = physx::PxVec3(pos.x, pos.y, pos.z);
    NMP_ASSERT(sphereDesc.isValid());
    scriptActor->m_actor = PxCreateRigidStatic(sphereDesc);
    NMP_ASSERT(scriptActor->m_actor);
  }

  m_scene->getPhysXScene()->addActor(*scriptActor->m_actor);

  return scriptActor;
}



// ---------------------------------------------------------------------------------------------------------------------
namespace ScriptWrappers
{

// ---------------------------------------------------------------------------------------------------------------------
SqNetworkInstance* SqNetworkDef::createInstance(const char* instName, const NMP::Matrix34& initialTM)
{
  if (g_isLogOutputEnabled)
    NMP_MSG("Creating Instance '%s' from '%s'", instName, m_name.c_str());

  SqNetworkInstance* newInst = new SqNetworkInstance;
  newInst->m_name = instName;

  SceneData::NetworkState *ns = new SceneData::NetworkState;

#if defined(MR_OUTPUT_DEBUGGING)
  m_debugInterface = new MR::InstanceDebugInterface();
#else
  m_debugInterface = 0;
#endif

  ns->m_needUpdate = false;
  ns->m_network = Network::createInstance(
    m_def,
    m_debugInterface,
    m_persistAllocator,
    m_physicsScene,
    initialTM,
    ns->m_networkInstFootprint,
    &ns->m_euphoriaRootModule);

  // initialise the debug interfaces module names
  //
#if defined(MR_OUTPUT_DEBUGGING)
  const uint32_t maxModules = 120;
  const uint32_t maxModuleNameLength = 64;

  char allModuleNames[maxModules][maxModuleNameLength];
  char allModuleParentNames[maxModules][maxModuleNameLength];
  char* moduleNames[maxModules];
  char* moduleParentNames[maxModules];
  for (uint32_t i = 0; i < maxModules; ++i)
  {
    moduleNames[i] = (char*) & (allModuleNames[i]);
    moduleParentNames[i] = (char*) & (allModuleParentNames[i]);
  }

  int32_t numModules = 0;
  if (ns->m_euphoriaRootModule)
  {
    ns->m_euphoriaRootModule->getModuleNames(
      &allModuleNames[0][0],
      &allModuleParentNames[0][0],
      maxModuleNameLength,
      numModules);
  }

  NMP_ASSERT((uint32_t)numModules <= maxModules);
  m_debugInterface->initModuleNames(numModules, moduleNames, moduleParentNames);
#endif

  m_networkStates->push_back(ns);

  newInst->m_state = ns;

  return newInst;
}

// ---------------------------------------------------------------------------------------------------------------------
bool SqNetworkInstance::broadcastMessage(const char* messageName)
{
  if (g_isLogOutputEnabled)
    NMP_MSG("Broadcasting '%s' to '%s'...", messageName, m_name.c_str());

  MR::NetworkDef *networkDef = m_state->m_network->getNetworkDef();
  MR::MessageID messageID = networkDef->getMessageIDFromMessageName(messageName);

  if (messageID == MR::INVALID_MESSAGE_ID)
  {
    NMP_MSG("Warning: message '%s' not found", messageName);
    return false;
  }

  MR::Message requestMessage(messageID, MESSAGE_TYPE_REQUEST, true, 0, 0);
  return m_state->m_network->broadcastMessage(requestMessage) > 0;
}

// ---------------------------------------------------------------------------------------------------------------------
void SqNetworkInstance::addImpulseToChar(const NMP::Vector3& f)
{
  if (g_isLogOutputEnabled)
    NMP_MSG("Impulse('%f', '%f', '%f') to character", f.x, f.y, f.z);
  MR::PhysicsRigPhysX3Articulation *physicsRigPhysX = (MR::PhysicsRigPhysX3Articulation *)getPhysicsRig(m_state->m_network);
  physx::PxArticulationLink *actor = (physx::PxArticulationLink *)physicsRigPhysX->getPartPhysX3Articulation(0)->getArticulationLink();
  MR::addImpulseToActor(*actor, f);
}

// ---------------------------------------------------------------------------------------------------------------------
void SqNetworkInstance::addTorqueImpulseToChar(const NMP::Vector3& t)
{
  if (g_isLogOutputEnabled)
    NMP_MSG("Torque Impulse('%f', '%f', '%f') to character", t.x, t.y, t.z);
  MR::PhysicsRigPhysX3Articulation *physicsRigPhysX = (MR::PhysicsRigPhysX3Articulation *)getPhysicsRig(m_state->m_network);
  physx::PxArticulationLink *actor = (physx::PxArticulationLink *)physicsRigPhysX->getPartPhysX3Articulation(0)->getArticulationLink();
  MR::addTorqueImpulseToActor(*actor, t);
}

// ---------------------------------------------------------------------------------------------------------------------
NMP::Vector3 SqNetworkInstance::getRootCharPosition()
{
  MR::PhysicsRigPhysX3Articulation *physicsRigPhysX = (MR::PhysicsRigPhysX3Articulation *)getPhysicsRig(m_state->m_network);
  physx::PxArticulationLink *actor = (physx::PxArticulationLink *)physicsRigPhysX->getPartPhysX3Articulation(0)->getArticulationLink();
  physx::PxTransform pxTm = actor->getGlobalPose();

  return NMP::Vector3(pxTm.p.x, pxTm.p.y, pxTm.p.z);
}

// ---------------------------------------------------------------------------------------------------------------------
NMP::Vector3 SqNetworkInstance::getRootCharVelocity()
{
  MR::PhysicsRigPhysX3Articulation *physicsRigPhysX = (MR::PhysicsRigPhysX3Articulation *)getPhysicsRig(m_state->m_network);
  physx::PxArticulationLink *actor = (physx::PxArticulationLink *)physicsRigPhysX->getPartPhysX3Articulation(0)->getArticulationLink();
  physx::PxVec3 pxVel = actor->getLinearVelocity();

  return NMP::Vector3(pxVel.x, pxVel.y, pxVel.z);
}

// ---------------------------------------------------------------------------------------------------------------------
NMP::Vector3 SqNetworkInstance::getLeftHandPosition()
{
  return getLeftHandTM().translation();
}
// ---------------------------------------------------------------------------------------------------------------------
NMP::Vector3 SqNetworkInstance::getRightHandPosition()
{
  return getRightHandTM().translation();
}

// ---------------------------------------------------------------------------------------------------------------------
NMP::Matrix34 SqNetworkInstance::getLeftHandTM()
{
  NM_BEHAVIOUR_LIB_NAMESPACE::Arm* armModule = (NM_BEHAVIOUR_LIB_NAMESPACE::Arm*)
    m_state->m_euphoriaRootModule->getModule(NM_BEHAVIOUR_LIB_NAMESPACE::NetworkManifest::arms_1);

  if (armModule && m_state->m_euphoriaRootModule->isEnabled(NM_BEHAVIOUR_LIB_NAMESPACE::NetworkManifest::arms_1))
  {
    return armModule->owner->data->armLimbSharedStates[armModule->data->childIndex].m_endTM;
  }
  return NMP::Matrix34Identity();
}

// ---------------------------------------------------------------------------------------------------------------------
NMP::Matrix34 SqNetworkInstance::getRightHandTM()
{
  NM_BEHAVIOUR_LIB_NAMESPACE::Arm* armModule = (NM_BEHAVIOUR_LIB_NAMESPACE::Arm*)
    m_state->m_euphoriaRootModule->getModule(NM_BEHAVIOUR_LIB_NAMESPACE::NetworkManifest::arms_0);

  if (armModule && m_state->m_euphoriaRootModule->isEnabled(NM_BEHAVIOUR_LIB_NAMESPACE::NetworkManifest::arms_0))
  {
    return armModule->owner->data->armLimbSharedStates[armModule->data->childIndex].m_endTM;
  }
  return NMP::Matrix34Identity();
}
// ---------------------------------------------------------------------------------------------------------------------
NMP::Vector3 SqNetworkInstance::getHeadPosition()
{
  NM_BEHAVIOUR_LIB_NAMESPACE::Head *head = (NM_BEHAVIOUR_LIB_NAMESPACE::Head *)
    m_state->m_euphoriaRootModule->getModule(NM_BEHAVIOUR_LIB_NAMESPACE::NetworkManifest::heads_0);
  if (head && m_state->m_euphoriaRootModule->isEnabled(NM_BEHAVIOUR_LIB_NAMESPACE::NetworkManifest::heads_0))
  {
    return head->owner->data->headLimbSharedStates[head->data->childIndex].m_endTM.translation();
  }
  return NMP::Vector3Zero();
}

// ---------------------------------------------------------------------------------------------------------------------
NMP::Vector3 SqNetworkInstance::getLookPosition()
{
  NM_BEHAVIOUR_LIB_NAMESPACE::Head *head = (NM_BEHAVIOUR_LIB_NAMESPACE::Head *)
    m_state->m_euphoriaRootModule->getModule(NM_BEHAVIOUR_LIB_NAMESPACE::NetworkManifest::heads_0);
  if (head && m_state->m_euphoriaRootModule->isEnabled(NM_BEHAVIOUR_LIB_NAMESPACE::NetworkManifest::heads_0))
  {
    return head->eyes->data->focalCentre;
  }
  return NMP::Vector3Zero();
}

// ---------------------------------------------------------------------------------------------------------------------
float SqNetworkInstance::getTimeSinceLastStep()
{
  NM_BEHAVIOUR_LIB_NAMESPACE::BodyBalance *bodyBalance = (NM_BEHAVIOUR_LIB_NAMESPACE::BodyBalance *) 
    m_state->m_euphoriaRootModule->getModule(NM_BEHAVIOUR_LIB_NAMESPACE::NetworkManifest::bodyFrame_bodyBalance);
  if (bodyBalance && 
    m_state->m_euphoriaRootModule->isEnabled(NM_BEHAVIOUR_LIB_NAMESPACE::NetworkManifest::bodyFrame_bodyBalance))
  {
    return bodyBalance->data->timeSinceLastStep;
  }
  return 0.0f;
}

// ---------------------------------------------------------------------------------------------------------------------
void SqNetworkInstance::setCharVelocity(const NMP::Vector3& vel)
{
  if (g_isLogOutputEnabled)
    NMP_MSG("Set velocity('%f', '%f', '%f' of the character", vel.x, vel.y, vel.z);
  MR::PhysicsRigPhysX3Articulation *physicsRigPhysX = (MR::PhysicsRigPhysX3Articulation*) getPhysicsRig(m_state->m_network);
  uint32_t numParts = physicsRigPhysX->getNumParts();
  for (uint32_t i = 0 ; i < numParts ; i++)
  {
    physx::PxArticulationLink *actor = 
      (physx::PxArticulationLink*) physicsRigPhysX->getPartPhysX3Articulation(i)->getArticulationLink();
    actor->setLinearVelocity(physx::PxVec3(vel.x, vel.y, vel.z));
  }
}

// ---------------------------------------------------------------------------------------------------------------------
void SqNetworkInstance::translateChar(const NMP::Vector3& translation)
{
  if (g_isLogOutputEnabled)
    NMP_MSG("Translate character by ('%f', '%f', '%f')", translation.x, translation.y, translation.z);
  MR::PhysicsRigPhysX3Articulation *physicsRigPhysX = (MR::PhysicsRigPhysX3Articulation *)getPhysicsRig(m_state->m_network);
  uint32_t numParts = physicsRigPhysX->getNumParts();
  for (uint32_t i = 0 ; i < numParts ; i++)
  {
    physx::PxArticulationLink *actor = 
      (physx::PxArticulationLink*) physicsRigPhysX->getPartPhysX3Articulation(i)->getArticulationLink();
    physx::PxVec3 t1(translation.x, translation.y, translation.z);
    physx::PxTransform pose = actor->getGlobalPose();
    pose.p += t1;
    actor->setGlobalPose(pose);
  }
}

// ---------------------------------------------------------------------------------------------------------------------
void SqNetworkInstance::rotateChar(const NMP::Vector3& rot)
{
  NMP_MSG("Rotate character by ('%f', '%f', '%f')", rot.x, rot.y, rot.z);
  MR::PhysicsRigPhysX3Articulation *physicsRigPhysX = (MR::PhysicsRigPhysX3Articulation*) getPhysicsRig(m_state->m_network);
  uint32_t numParts = physicsRigPhysX->getNumParts();
  physx::PxVec3 rootPos = MR::nmVector3ToPxVec3(getRootCharPosition());
  physx::PxQuat q(rot.magnitude(), MR::nmVector3ToPxVec3(rot.getNormalised()));
  for (uint32_t i = 0 ; i < numParts ; i++)
  {
    physx::PxArticulationLink *actor = 
      (physx::PxArticulationLink*) physicsRigPhysX->getPartPhysX3Articulation(i)->getArticulationLink();
    physx::PxTransform pose = actor->getGlobalPose();

    physx::PxVec3 r = pose.p - rootPos;
    r = q.rotate(r);
    pose.p = rootPos + r;
    pose.q = q * pose.q;
    actor->setGlobalPose(pose);
  }
}

// ---------------------------------------------------------------------------------------------------------------------
void SqNetworkInstance::setCharControllerTransform(const NMP::Matrix34& tm)
{
  if (g_isLogOutputEnabled)
    NMP_MSG("Set character controller to ('%f', '%f', '%f')", tm.translation().x, tm.translation().y, tm.translation().z);
  m_state->m_network->setCharacterPropertiesWorldRootTransform(tm);
}

// ---------------------------------------------------------------------------------------------------------------------
int SqNetworkInstance::getNumConstrainedArms()
{
  int numConstrainedArms = -1;
  NM_BEHAVIOUR_LIB_NAMESPACE::HoldBehaviourInterfaceWrapper holdBI(m_state->m_euphoriaRootModule->getCharacter());
  if (holdBI.isAvailable())
  {
   return holdBI.getNumConstrainedArms();
  }
  return numConstrainedArms;
}

// ---------------------------------------------------------------------------------------------------------------------
void SqNetworkInstance::storeState()
{
  m_state->m_euphoriaRootModule->getCharacter()->storeState(m_savedState);
}

// ---------------------------------------------------------------------------------------------------------------------
void SqNetworkInstance::restoreState()
{
  m_state->m_euphoriaRootModule->getCharacter()->restoreState(m_savedState);
}

// ---------------------------------------------------------------------------------------------------------------------
void SqNetworkInstance::disableBehaviourEffects()
{
  m_state->m_euphoriaRootModule->getCharacter()->disableBehaviourEffects();
}

// ---------------------------------------------------------------------------------------------------------------------
bool SqNetworkInstance::isBalanced()
{
  NM_BEHAVIOUR_LIB_NAMESPACE::BalanceBehaviourInterfaceWrapper balanceBI(m_state->m_euphoriaRootModule->getCharacter());

  if (balanceBI.isAvailable())
  {
    return balanceBI.getBalanceAmount() > 0.0f;
  }
   return false;
}

// ---------------------------------------------------------------------------------------------------------------------
bool SqNetworkInstance::isInFreefall()
{
  NM_BEHAVIOUR_LIB_NAMESPACE::FreeFallBehaviourInterfaceWrapper freeFallBI(m_state->m_euphoriaRootModule->getCharacter());

  if (freeFallBI.isAvailable())
  {
    return freeFallBI.getIsInFreefall();
  }
  return false;
}

// ---------------------------------------------------------------------------------------------------------------------
bool SqNetworkInstance::isShielding()
{
  NM_BEHAVIOUR_LIB_NAMESPACE::ShieldBehaviourInterfaceWrapper shieldBI(m_state->m_euphoriaRootModule->getCharacter());

  if (shieldBI.isAvailable())
  {
    return shieldBI.getIsShielding();
  }
  return false;
}

// ---------------------------------------------------------------------------------------------------------------------
bool SqNetworkInstance::hasHeadCollided()
{
  NM_BEHAVIOUR_LIB_NAMESPACE::Head *head = (NM_BEHAVIOUR_LIB_NAMESPACE::Head *)
    m_state->m_euphoriaRootModule->getModule(NM_BEHAVIOUR_LIB_NAMESPACE::NetworkManifest::heads_0);
  if (!head || !m_state->m_euphoriaRootModule->isEnabled(NM_BEHAVIOUR_LIB_NAMESPACE::NetworkManifest::heads_0))
  {
    return false; 
  }
  return head->data->headInContact;
}

// ---------------------------------------------------------------------------------------------------------------------
bool SqNetworkInstance::hasChestCollided()
{
  NM_BEHAVIOUR_LIB_NAMESPACE::Head *head = (NM_BEHAVIOUR_LIB_NAMESPACE::Head *)
    m_state->m_euphoriaRootModule->getModule(NM_BEHAVIOUR_LIB_NAMESPACE::NetworkManifest::heads_0);
  if (!head || !m_state->m_euphoriaRootModule->isEnabled(NM_BEHAVIOUR_LIB_NAMESPACE::NetworkManifest::heads_0))
  {
    return false; 
  }
  return head->data->chestInContact;
}

// ---------------------------------------------------------------------------------------------------------------------
bool SqNetworkInstance::setFloatControlParameter(const char* CPName, const float CPFloat)
{
  if (g_isLogOutputEnabled)
    NMP_MSG("Set control parameter '%s' with a value of '%f'", CPName, CPFloat);
  MR::NodeID CPID = m_state->m_network->getNetworkDef()->getNodeIDFromNodeName(CPName);

  bool CPFound = CPID != MR::INVALID_NODE_ID;
  if (CPFound)
  {
   MR::AttribDataFloat floatAttribData;
   floatAttribData.m_value = CPFloat;
    m_state->m_network->setControlParameter(CPID, &floatAttribData);
  }
  return CPFound;
}

// ---------------------------------------------------------------------------------------------------------------------
bool SqNetworkInstance::setVectorControlParameter(const char* CPName, const NMP::Vector3& CPVec)
{
  if (g_isLogOutputEnabled)
    NMP_MSG("Set control parameter '%s' with a value of vector('%f', '%f', '%f') ", CPName, CPVec.x, CPVec.y, CPVec.z);
  MR::NodeID CPID = m_state->m_network->getNetworkDef()->getNodeIDFromNodeName(CPName);

  bool CPFound = CPID != MR::INVALID_NODE_ID;
  if (CPFound)
  {
    MR::AttribDataVector3 vecAttribData;
    vecAttribData.m_value = CPVec;
    m_state->m_network->setControlParameter(CPID, &vecAttribData);
  }
  return CPFound;
}

// ---------------------------------------------------------------------------------------------------------------------
void SqPhysXActor::addImpulse(const NMP::Vector3& f)
{
  if (g_isLogOutputEnabled)
    NMP_MSG("Impulse('%f', '%f', '%f') to object", f.x, f.y, f.z);
  MR::addImpulseToActor(*m_actor, f);
}

// ---------------------------------------------------------------------------------------------------------------------
void SqPhysXActor::addAngularImpulse(const NMP::Vector3& ap)
{
  if (g_isLogOutputEnabled)
    NMP_MSG("Angular Impulse('%f', '%f', '%f') to object", ap.x, ap.y, ap.z);
  m_actor->isRigidBody()->addTorque(physx::PxVec3(ap.x, ap.y, ap.z), physx::PxForceMode::eIMPULSE);
}

// ---------------------------------------------------------------------------------------------------------------------
void SqPhysXActor::addImpulseAtPos(const NMP::Vector3& f, const NMP::Vector3& pt)
{
  if (g_isLogOutputEnabled)
    NMP_MSG("Impulse('%f', '%f', '%f') at position('%f', '%f', '%f') to object", f.x, f.y, f.z, pt.x, pt.y, pt.z);
  MR::addImpulseToActor(*m_actor, f, pt);
}

// ---------------------------------------------------------------------------------------------------------------------
void SqPhysXActor::addForce(const NMP::Vector3& f)
{
  if (g_isLogOutputEnabled)
    NMP_MSG("Force('%f', '%f', '%f') to object", f.x, f.y, f.z);
  physx::PxVec3 p = m_actor->isRigidBody()->getGlobalPose().p;
  MR::addForceToActor(*m_actor, f, NMP::Vector3(p.x, p.y, p.z));
}

// ---------------------------------------------------------------------------------------------------------------------
void SqPhysXActor::setVelocity(const NMP::Vector3& vel)
{
  if (g_isLogOutputEnabled)
    NMP_MSG("Set velocity('%f', '%f', '%f' of an object", vel.x, vel.y, vel.z);
  m_actor->isRigidDynamic()->setLinearVelocity(physx::PxVec3(vel.x,vel.y,vel.z));
}

// ---------------------------------------------------------------------------------------------------------------------
void SqPhysXActor::addForceAtPos(const NMP::Vector3& f, const NMP::Vector3& pt)
{
  if (g_isLogOutputEnabled)
    NMP_MSG("Force('%f', '%f', '%f') at position('%f', '%f', '%f') to object", f.x, f.y, f.z, pt.x, pt.y, pt.z);
  MR::addForceToActor(*m_actor, f, pt);
}

// ---------------------------------------------------------------------------------------------------------------------
void SqPhysXActor::addTorque(const NMP::Vector3& t)
{
  if (g_isLogOutputEnabled)
    NMP_MSG("Torque('%f', '%f', '%f') to object", t.x, t.y, t.z);
  m_actor->isRigidBody()->addTorque(physx::PxVec3(t.x, t.y, t.z), physx::PxForceMode::eFORCE);
}

// ---------------------------------------------------------------------------------------------------------------------
NMP::Matrix34 SqPhysXActor::getGlobalTransform()
{
  return MR::nmPxTransformToNmMatrix34(m_actor->isRigidBody()->getGlobalPose());
}

// ---------------------------------------------------------------------------------------------------------------------
void SqPhysXActor::setPosition(const NMP::Vector3 &position)
{
  m_actor->isRigidBody()->setGlobalPose(physx::PxTransform(MR::nmVector3ToPxVec3(position), physx::PxQuat(0,0,0,1)));
}

} // namespace ScriptWrappers


// ---------------------------------------------------------------------------------------------------------------------
DECLARE_INSTANCE_TYPE_NAME(SceneData, scene);
DECLARE_INSTANCE_TYPE(PhysicsAPI);
DECLARE_NON_COPYABLE_INSTANCE_TYPE_NAME(ScriptWrappers::SqNetworkDef, SqNetworkDef);
DECLARE_NON_COPYABLE_INSTANCE_TYPE_NAME(ScriptWrappers::SqNetworkInstance, SqNetworkInstance);
DECLARE_NON_COPYABLE_INSTANCE_TYPE_NAME(ScriptWrappers::SqPhysXActor, SqPhysXActor);


// ---------------------------------------------------------------------------------------------------------------------
void SceneData::registerForScripting(sqp::SquirrelVM& vm)
{
  sqp::ClassDefNoConstructor<SceneData>(vm, "scene")
    .SingletonFunc(this, &SceneData::setCurrentDirectory, "setCurrentDirectory")
    .SingletonFunc(this, &SceneData::loadNetworkDef, "loadNetworkDef")
    .SingletonFunc(this, &SceneData::loadDefaultNetworkDef, "loadDefaultNetworkDef")
    .SingletonFunc(this, &SceneData::updateAll, "updateAll")
    .SingletonFunc(this, &SceneData::getPhysicsAPI, "physics")
    ;

  sqp::ClassDefNoConstructor<ScriptWrappers::SqNetworkDef>(vm, "SqNetworkDef")
    .Func(&ScriptWrappers::SqNetworkDef::createInstance, "createInstance")
    ;

  sqp::ClassDefNoConstructor<ScriptWrappers::SqNetworkInstance>(vm, "SqNetworkInstance")
    .Func(&ScriptWrappers::SqNetworkInstance::broadcastMessage, "broadcastMessage")
    .Func(&ScriptWrappers::SqNetworkInstance::setFloatControlParameter, "setFloatControlParameter")
    .Func(&ScriptWrappers::SqNetworkInstance::setVectorControlParameter, "setVectorControlParameter")
    .Func(&ScriptWrappers::SqNetworkInstance::getNumConstrainedArms, "getNumConstrainedArms")
    .Func(&ScriptWrappers::SqNetworkInstance::isBalanced, "isBalanced")
    .Func(&ScriptWrappers::SqNetworkInstance::isInFreefall, "isInFreefall")
    .Func(&ScriptWrappers::SqNetworkInstance::isShielding, "isShielding")
    .Func(&ScriptWrappers::SqNetworkInstance::hasHeadCollided, "hasHeadCollided")
    .Func(&ScriptWrappers::SqNetworkInstance::hasChestCollided, "hasChestCollided")
    .Func(&ScriptWrappers::SqNetworkInstance::addImpulseToChar, "addImpulseToChar")
    .Func(&ScriptWrappers::SqNetworkInstance::addTorqueImpulseToChar, "addTorqueImpulseToChar")
    .Func(&ScriptWrappers::SqNetworkInstance::getRootCharPosition, "getRootCharPosition")
    .Func(&ScriptWrappers::SqNetworkInstance::getRootCharVelocity, "getRootCharVelocity")
    .Func(&ScriptWrappers::SqNetworkInstance::getLeftHandPosition, "getLeftHandPosition")
    .Func(&ScriptWrappers::SqNetworkInstance::getRightHandPosition, "getRightHandPosition")
    .Func(&ScriptWrappers::SqNetworkInstance::getRightHandTM, "getRightHandTM")
    .Func(&ScriptWrappers::SqNetworkInstance::getLeftHandTM, "getLeftHandTM")
    .Func(&ScriptWrappers::SqNetworkInstance::getHeadPosition, "getHeadPosition")
    .Func(&ScriptWrappers::SqNetworkInstance::getLookPosition, "getLookPosition")
    .Func(&ScriptWrappers::SqNetworkInstance::getTimeSinceLastStep, "getTimeSinceLastStep")
    .Func(&ScriptWrappers::SqNetworkInstance::setCharVelocity, "setCharVelocity")
    .Func(&ScriptWrappers::SqNetworkInstance::translateChar, "translateChar")
    .Func(&ScriptWrappers::SqNetworkInstance::rotateChar, "rotateChar")
    .Func(&ScriptWrappers::SqNetworkInstance::setCharControllerTransform, "setCharControllerTransform")
    .Func(&ScriptWrappers::SqNetworkInstance::storeState, "storeState")
    .Func(&ScriptWrappers::SqNetworkInstance::restoreState, "restoreState")
    .Func(&ScriptWrappers::SqNetworkInstance::disableBehaviourEffects, "disableBehaviourEffects")
    ;

  sqp::ClassDefNoConstructor<ScriptWrappers::SqPhysXActor>(vm, "SqPhysXActor")
    .Func(&ScriptWrappers::SqPhysXActor::addImpulse, "addImpulse")
    .Func(&ScriptWrappers::SqPhysXActor::addAngularImpulse, "addAngularImpulse")
    .Func(&ScriptWrappers::SqPhysXActor::addImpulseAtPos, "addImpulseAtPos")
    .Func(&ScriptWrappers::SqPhysXActor::addForce, "addForce")
    .Func(&ScriptWrappers::SqPhysXActor::addForceAtPos, "addForceAtPos")
    .Func(&ScriptWrappers::SqPhysXActor::addTorque, "addTorque")
    .Func(&ScriptWrappers::SqPhysXActor::getGlobalTransform, "getGlobalTransform")
    .Func(&ScriptWrappers::SqPhysXActor::setPosition, "setPosition")
    .Func(&ScriptWrappers::SqPhysXActor::getMass, "getMass")
    .Func(&ScriptWrappers::SqPhysXActor::setVelocity, "setVelocity")
    ;

  sqp::ClassDefNoConstructor<PhysicsAPI>(vm, "PhysicsAPI")
    .Func(&PhysicsAPI::createBox<false>, "createStaticBox")
    .Func(&PhysicsAPI::createBox<true>, "createBox")
    .Func(&PhysicsAPI::createSphere<false>, "createStaticSphere")
    .Func(&PhysicsAPI::createSphere<true>, "createSphere")
    .Func(&PhysicsAPI::createCapsule<false>, "createStaticCapsule")
    .Func(&PhysicsAPI::createCapsule<true>, "createCapsule")
    ;
}

// ---------------------------------------------------------------------------------------------------------------------
void SceneData::NetworkState::updateNetworkStart(float deltaTime)
{
  NM_BEGIN_PROFILING("Start_Update");
  MR::Network *network = m_network;
  network->startUpdate(deltaTime);
  m_needUpdate = true;
  NM_END_PROFILING();
}

// ---------------------------------------------------------------------------------------------------------------------
void SceneData::NetworkState::updateNetworkPreController(float)
{
  NM_BEGIN_PROFILING("Pre_Controller");
  if (m_needUpdate)
  {
    MR::Network *network = m_network;
    MR::Task *task = 0;
    while (network->update(task))
    {
      if (task && task->m_taskid == MR::CoreTaskIDs::MR_TASKID_NETWORKUPDATECHARACTERCONTROLLER)
      {
        break;
      }
    }
    if (!task)
    {
      m_needUpdate = false;
    }
  }
  NM_END_PROFILING();
}

// ---------------------------------------------------------------------------------------------------------------------
void SceneData::NetworkState::updateNetworkPostController(float)
{
  NM_BEGIN_PROFILING("Post_Controller");
  NM_END_PROFILING();
}

// ---------------------------------------------------------------------------------------------------------------------
void SceneData::NetworkState::updateNetworkPrePhysics(float deltaTime)
{
  NM_BEGIN_PROFILING("Pre_Physics");
  if (m_needUpdate)
  {
    MR::Network *network = m_network;
    MR::Task *task = 0;
    while (network->update(task))
    {
      if (task && task->m_taskid == MR::CoreTaskIDs::MR_TASKID_NETWORKUPDATEPHYSICS)
      {
        break;
      }
    }
    if (!task)
    {
      m_needUpdate = false;
    }

    NM_BEGIN_PROFILING("Pre_Physics_Euphoria");
    ER::Character *character =  ER::networkGetCharacter(network);

    if (character)
    {
      if (network->areBehaviourNodesActive())
      {
        character->prePhysicsStep(deltaTime); 
      }
      else
      {
        character->disableBehaviourEffects();
      }
    }

    MR::PhysicsRigPhysX3Articulation *physicsRigPhysX = (MR::PhysicsRigPhysX3Articulation *)getPhysicsRig(network);
    if (physicsRigPhysX)
      physicsRigPhysX->updatePrePhysics(deltaTime);
    
    NM_END_PROFILING(); // End of Pre_Physics_Euphoria
  }

  NM_END_PROFILING(); // End of Pre_Physics
}

// ---------------------------------------------------------------------------------------------------------------------
void SceneData::NetworkState::updateNetworkPostPhysics(float deltaTime)
{
  NM_BEGIN_PROFILING("Post_Physics");
  if (m_needUpdate)
  {
    NM_BEGIN_PROFILING("Post_Physics_Euphoria");
    MR::Network *network = m_network;

    MR::PhysicsRigPhysX3Articulation *physicsRigPhysX = (MR::PhysicsRigPhysX3Articulation *)getPhysicsRig(network);
    if (physicsRigPhysX)
      physicsRigPhysX->updatePostPhysics(deltaTime);
    
    ER::Character *character = ER::networkGetCharacter(network);

    if (character)
    {
      if (network->areBehaviourNodesActive())
      {
        character->postPhysicsStep(deltaTime); 
      }
    }
    NM_END_PROFILING(); // End of Post_Physics_Euphoria
    MR::Task *task = 0;
    while (network->update(task))
    {
      if (task && task->m_taskid == MR::CoreTaskIDs::MR_TASKID_NETWORKUPDATEROOT)
      {
        break;
      }
    }
    if (!task)
    {
      m_needUpdate = false;
    }
  }
  NM_END_PROFILING();  
}

// ---------------------------------------------------------------------------------------------------------------------
void SceneData::NetworkState::updateNetworkRoot(float)
{
  NM_BEGIN_PROFILING("Update_Root");
  if (m_needUpdate)
  {
    MR::Network *network = m_network;
    MR::Task *task = 0;
    while (network->update(task) != MR::EXECUTE_RESULT_COMPLETE)
    {
    }

    m_needUpdate = false;
  }
  NM_END_PROFILING();

  NMP::TempMemoryAllocator* tempAllocator = m_network->getTempMemoryAllocator();
  tempAllocator->reset();
}
