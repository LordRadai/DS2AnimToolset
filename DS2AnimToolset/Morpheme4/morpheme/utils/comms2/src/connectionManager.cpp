// Copyright (c) 2010 NaturalMotion.  All Rights Reserved.
// Not to be copied, adapted, modified, used, distributed, sold,
// licensed or commercially exploited in any manner without the
// written consent of NaturalMotion.
//
// All non public elements of this software are the confidential
// information of NaturalMotion and may not be disclosed to any
// person nor used for any purpose not expressly approved by
// NaturalMotion in writing.

//----------------------------------------------------------------------------------------------------------------------
#include "NMPlatform/NMPlatform.h"
#include "NMPlatform/NMFastHeapAllocator.h"
#include "NMPlatform/NMSocketWrapper.h"
#include "comms/MCOMMS.h"
#include "comms/connectionManager.h"
#include "comms/packet.h"
#include "comms/corePackets.h"
#include "comms/connection.h"
#include "comms/commsServer.h"
#include "comms/runtimeTargetInterface.h"
//----------------------------------------------------------------------------------------------------------------------

// Disable warnings constant conditionals
// Generated by calling FD_SET() in winsock.h
#ifdef NM_COMPILER_MSVC
  #pragma warning (push)
  #pragma warning(disable : 4127)
#endif

#ifdef NMVERBOSE
  #include <stdio.h>
#endif

namespace MCOMMS
{

namespace
{

//----------------------------------------------------------------------------------------------------------------------
SocketStatus checkConnectionsInboundActivity(ConnectionManager* const connectionManager, NMP::fd_set& readSockets)
{
  // All sockets can be checked with a single select command.
  FD_ZERO(&readSockets);

  Connection* const connection = connectionManager->getConnection(0);
  NMP_ASSERT(connection->getCommandsSocket()->isValid() == true);
  FD_SET(connection->getCommandsSocket()->getSocket(), &readSockets);
  int32_t maxSock = (int32_t)(connection->getCommandsSocket()->getSocket());

  for (uint32_t i = 1; i < connectionManager->getNumConnections(); ++i)
  {
    Connection* connectionI = connectionManager->getConnection(i);
    NMP_ASSERT(connectionI->getCommandsSocket()->isValid() == true);
    NMP::socket_t sockVal = connectionI->getCommandsSocket()->getSocket();
    FD_SET(sockVal, &readSockets);
    if ((int)sockVal > maxSock)
    {
      maxSock = (int)sockVal;
    }
  }

  ++maxSock;

  // Set timeout values for ::select. A reasonable timeout value is needed in order to avoid spinning around this
  // and losing potential step messages.  We check for messages on all of our connections in one go.
  int32_t socketsWithMessages = NMP::getSocketsWithMessages(maxSock, &readSockets, 0, 0, 15000);

  // Some of the checked sockets has messages.
  if (socketsWithMessages > 0)
  {
    return SOCKET_HAS_MESSAGES;
  }

  // Check for errors. This is not a connection specific error.
  // The thread needs to terminate and close all the connections.
  if (socketsWithMessages == -1)
  {
    return SOCKET_ERROR_OCCURRED;
  }

  return SOCKET_NO_MESSAGES;
}

//----------------------------------------------------------------------------------------------------------------------
bool acceptConnection(NMP::SocketWrapper& listenSocket, NMP::SocketWrapper& newSocket, uint32_t timeOutMSec)
{
  NMP::sockaddr_in theirAddr;
  int theirAddrLen = sizeof(theirAddr);

  NMP::fd_set readSockets;
  FD_ZERO(&readSockets);
  FD_SET(listenSocket.getSocket(), &readSockets);
  int maxSock = (int)listenSocket.getSocket();

  // Check for messages.
  // On windows, the first ("maxSock") parameter to select() is ignored.
  int hasMessages = NMP::getSocketsWithMessages(maxSock + 1, &readSockets, 0, 0, timeOutMSec * 1000);

  // Check for errors or no activity.
  if (hasMessages == -1 || hasMessages == 0)
  {
    return false;
  }

  // create a new socket for the new connection
  NMP::socket_t accepted = NMP::accept(
                        listenSocket.getSocket(),
                        (NMP::sockaddr*)&theirAddr,
                        (NMP::socklen_t*)&theirAddrLen);

  if (accepted == NMP::SOCKET_ERROR_INVALID)
  {
    NMP_MSG("MorphemeComms: An error occurred trying to accept a connection.");
    return false;
  }

  // The connection has succeeded, attach the socket to the wrapper.
  newSocket.setSocket(accepted);
  NMP_ASSERT(newSocket.isValid() == true);

  // Try to disable Nagle algorithm buffering
#if !defined(NM_HOST_NO_SOCKET_NODELAY)
  uint32_t flag = 0xffffffff;
  if (NMP::setsockopt(newSocket.getSocket(), IPPROTO_TCP, TCP_NODELAY, (void*)&flag, sizeof(flag)) == -1)
  {
    return false;
  }
#endif

  return true;
}

//----------------------------------------------------------------------------------------------------------------------
} // anonymous namespace

//----------------------------------------------------------------------------------------------------------------------
bool ConnectionManager::canStartNewConnection()
{
  if (m_tempCommandsSocket->isValid() && m_tempDataSocket->isValid() && m_tempFileServerSocket->isValid())
  {
    return true;
  }

  // The connection is established connecting the three sockets in the following order:
  // 1) commands socket
  // 2) data socket
  // 3) fileserver socket

  // Check if a connection process has already started.
  uint32_t checkTimeOutMSec = 0;
  if (m_tempCommandsSocket->isValid())
  {
    if (m_tempDataSocket->isValid())
    {
      acceptConnection(*m_listenFileServerSocket, *m_tempFileServerSocket, checkTimeOutMSec);
      return false;
    }

    acceptConnection(*m_listenDataSocket, *m_tempDataSocket, checkTimeOutMSec);
    return false;
  }

  acceptConnection(*m_listenCommandsSocket, *m_tempCommandsSocket, checkTimeOutMSec);
  return false;
}

//----------------------------------------------------------------------------------------------------------------------
Connection* ConnectionManager::getMasterConnection() const
{
  for (uint32_t i = 0; i < getNumConnections(); ++i)
  {
    Connection* connection = getConnection(i);
    if (connection->isMaster())
    {
      return connection;
    }
  }
  return 0;
}

//----------------------------------------------------------------------------------------------------------------------
bool ConnectionManager::closeSocket(NMP::SocketWrapper* socketWrapper)
{
  NMP_ASSERT(socketWrapper);
  if (socketWrapper->isValid())
  {
    NMP::shutdown(socketWrapper->getSocket(), 0x02);
    NMP::closesocket(socketWrapper->getSocket());
    socketWrapper->setInvalid();
    return true;
  }

  return false;
}

//----------------------------------------------------------------------------------------------------------------------
bool ConnectionManager::handleCommandOnConnection(Connection* connection, bool& gotMasterStep)
{
  NetworkDataBuffer::ScopedBuffer scopedBuffer(&m_commandsBuffer);

  // Try to receive a packet on this connection.
  CmdPacketBase* cmdPacket = connection->receiveCommandPacket(&m_commandsBuffer);
  if (!cmdPacket)
  {
    // Not getting a valid packet means that an error occurred, because
    // activity on the socket was previously checked.
    closeSocket(connection->getCommandsSocket());
    return false;
  }

  uint16_t pktId = cmdPacket->hdr.m_id;
  NMP::netEndianSwap(pktId);

  switch (pktId)
  {
  case pk_PingCmd:
    {
#ifdef MCOMMS_VERBOSE
      NMP_MSG("MorphemeComms: received ping packet.");
#endif
      // reply with another ping packet.
      PingCmdPacket* pingPacket = (PingCmdPacket*)cmdPacket;
      pingPacket->deserialize();

      connection->sendPingPacket(pingPacket->m_id);

      CommsServer::getInstance()->sendTargetStatus(connection);
    }
    break;

  default:
    CommsServer::getInstance()->handleCmdPacket(cmdPacket, connection, gotMasterStep);
    break;
  }

  return true;
}

//----------------------------------------------------------------------------------------------------------------------
void ConnectionManager::updateClientConnections()
{
  // Remove dead connections
  // -----------------------
  for (uint32_t iConn = 0; iConn < getNumConnections(); ++iConn)
  {
    if (!getConnection(iConn)->isAlive())
    {
      NMP_MSG("Connection Manager: Connection closed... \n");
      CommsServer::getInstance()->onConnectionClosed(getConnection(iConn));
      removeConnection(iConn);
    }
  }

  // Check for a new connection
  // --------------------------
  // Prepare three socket for a new connection. The connection will be added only if the three sockets are valid.
  if (canStartNewConnection())
  {
    // All the connection sockets have been established correctly.
    // A new connection can be created.
    if (getNumConnections() < ConnectionManager::MAX_NUMBER_CONNECTIONS)
    {
      NMP_MSG("ConnectionManager: new connection added\n");
      Connection* newConnection = addConnection(*m_tempCommandsSocket, *m_tempDataSocket, *m_tempFileServerSocket);

      CommsServer::getInstance()->onNewConnection(newConnection);
    }
    else
    {
      NMP_MSG("Connection manager: Too many connections. Rejecting connection attempt.\n");
      NMP::closesocket(m_tempCommandsSocket->getSocket());
      NMP::closesocket(m_tempDataSocket->getSocket());
      NMP::closesocket(m_tempFileServerSocket->getSocket());
    }

    // Reset the temporary socket wrappers, so that they can be used to accept new connections.
    m_tempCommandsSocket->setInvalid();
    m_tempDataSocket->setInvalid();
    m_tempFileServerSocket->setInvalid();
  }
}

//----------------------------------------------------------------------------------------------------------------------
bool ConnectionManager::shouldStep() const
{
  Connection* masterConnection = getMasterConnection();
  NMP_ASSERT(masterConnection);

  RuntimeTargetInterface* target = getRuntimeTarget();
  bool canStepInSynch = true;
  bool canPause = true;
  PlaybackManagementInterface* playbackMgr = target->getPlaybackManager();
  if (playbackMgr)
  {
    canStepInSynch = playbackMgr->canStepInSynch();
    canPause = playbackMgr->canPause();
  }

  // If the master connection cannot step in synch, then override the step,
  // as the game loop should not block on comms.
  // The step here can happen only either if the master connection is not in pause, or if the pause is not
  // allowed. Note that this means that the effect of 'pausing the playback' in connect is that we stop receiving
  // frames, but the runtime keeps going (networks are updated).
  if (!canStepInSynch && (!masterConnection->isSessionPaused() || !canPause))
  {
    return true;
  }

  // Another case where we want to step happens when the rtt allows synch stepping but doesn't allow pausing.
  // In this case, only if the asynch mode is enabled, we leave the comms update with a step.
  // Again, the effect is that connect doesn't receive frames but the networks are updated.
  if (canStepInSynch &&
      masterConnection->isAsynchronousSteppingEnabled() &&
      !canPause &&
      masterConnection->isSessionPaused())
  {
    return true;
  }

  return false;
}

//----------------------------------------------------------------------------------------------------------------------
bool ConnectionManager::update(bool& gotStep)
{
  NMP_ASSERT(m_initialized); // Should never update before initialization.

  // Connection manager update mechanism
  // -----------------------------------
  // Check all the connections for activity on the command socket.

  gotStep = false;

  // Check for new connections and remove dead ones.
  updateClientConnections();

  // Return immediately if no connections available. Note that a target that loads networks autonomously (eg: a game)
  // will (likely) do a full step and update the available networks.
  if (getNumConnections() == 0)
  {
    return true;
  }

  Connection* masterConnection = getMasterConnection();
  NMP_ASSERT(masterConnection);

  // The following is a 'set' (collection) of sockets to be used by the
  // FD_ZERO(), FD_SET(), FD_ISSET() and select() functions below.
  NMP::fd_set readSockets;

  ConnectionManager::Status internalStatus = ConnectionManager::kNoError;

  // Check for activity on the already existing command sockets and try to consume all the commands.
  // Exit the loop early only if a step on the master connection has arrived.
  bool noCommandsReceived = false;
  while (!noCommandsReceived)
  {
    // All sockets can be checked with a single select command.
    SocketStatus socketsStatus = checkConnectionsInboundActivity(this, readSockets);
    if (socketsStatus == SOCKET_ERROR_OCCURRED)
    {
      NMP_MSG("MorphemeComms: An error occurred while checking the sockets for activity.");
      internalStatus = ConnectionManager::kSocketError;
      return false;
    }

    if (socketsStatus == SOCKET_NO_MESSAGES)
    {
      // No messages on any of the commands socket.
      noCommandsReceived = true;
    }
    else
    {
      bool gotMasterStep = false;

      // Deal with activity on connections' sockets.
      for (uint32_t iConn = 0; iConn < getNumConnections(); ++iConn)
      {
        Connection* connection = getConnection(iConn);

        // Check if any messages were received on this connection's socket.
        if (FD_ISSET(connection->getCommandsSocket()->getSocket(), &readSockets))
        {
          if (!handleCommandOnConnection(connection, gotMasterStep))
          {
            // Not getting a valid packet means that an error occurred, because
            // activity on the socket was previously checked.
            closeSocket(connection->getCommandsSocket());
            return false;
          }
        }
      }

      if (internalStatus != ConnectionManager::kNoError)
      {
        return false;
      }

      // If the master connection got a step, just break here. We want to give the step a higher priority.
      // Other commands stay on the network layer buffers and will be dealt with later.
      if (gotMasterStep)
      {
        gotStep = true;
        break;
      }
    }

    if (shouldStep())
    {
      gotStep = true;
      break;
    }
  }  // while (!noCommandsReceived)

  bool masterRunning = false;
  masterRunning = masterConnection->isSessionRunning() && !masterConnection->isSessionPaused();

  // Even if a master step command hasn't been received, we might want to step because the asynchronous mode
  // is enabled.
  if (!gotStep && masterConnection->isAsynchronousSteppingEnabled())
  {
    if (getNumConnections() != 0 && masterRunning)
    {
      gotStep = true;
    }
  }

  return true;
}

//----------------------------------------------------------------------------------------------------------------------
bool ConnectionManager::initListenSocket(NMP::SocketWrapper* listenSocket, int listenPort)
{
  int ret;
  int on = 1;

  // create socket to listen for new connections.
  NMP::sockaddr_in ourAddr;
  memset(&ourAddr, 0, sizeof(ourAddr));
  ourAddr.sin_family = AF_INET;
  ourAddr.sin_port   = htons((short)listenPort);
  ourAddr.sin_addr.s_addr = INADDR_ANY;

  NMP::socket_t sock = NMP::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (sock == NMP::SOCKET_ERROR_INVALID)
  {
    NMP_MSG("NMP::SOCKET_ERROR_INVALID");
    return false;
  }

  listenSocket->setSocket(sock);
  if (listenSocket->isValid() == false)
  {
    NMP_MSG("listen socket not valid");

    return false;
  }

  // Allow reuse of address
  ret = NMP::setsockopt(listenSocket->getSocket(), SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
  if (ret == NMP::SOCKET_ERROR_GENERAL)
  {
    NMP_MSG("MorphemeComms: error initializing listen socket.")
    return false;
  }

  if (ret != 0)
  {
    NMP_MSG("setsockopt failed!");

    NMP::closesocket(listenSocket->getSocket());
    listenSocket->setInvalid();
    return false;
  }

  ret = NMP::bind(listenSocket->getSocket(), (NMP::sockaddr*)&ourAddr, sizeof(ourAddr));
  if (ret < 0)
  {
    NMP_MSG("Socket bind failed!");

    NMP::closesocket(listenSocket->getSocket());
    listenSocket->setInvalid();
    return false;
  }

  ret = NMP::listen(listenSocket->getSocket(), MAX_NUMBER_CONNECTIONS);
  if (ret < 0)
  {
    NMP_MSG("Socket listen failed!");

    NMP::closesocket(listenSocket->getSocket());
    listenSocket->setInvalid();
    return false;
  }

  return true;
}

//----------------------------------------------------------------------------------------------------------------------
ConnectionManager::~ConnectionManager()
{
  NMP_ASSERT(!m_initialized); // Should have been terminated before calling the destructor.
}

//----------------------------------------------------------------------------------------------------------------------
ConnectionManager::Status ConnectionManager::init(int listenPort)
{
  NMP_ASSERT(!m_initialized); // Can't init twice.

  // Prepare the buffer used to receive commands.
  m_commandsBuffer.initReceiveBuffer(COMMANDS_PACKET_INITIAL_BUFFER_SIZE, NMP_NATURAL_TYPE_ALIGNMENT);

  // Prepare connection wrappers.
  m_numConnections = 0;
  for (uint32_t iConn = 0; iConn < MAX_NUMBER_CONNECTIONS; ++iConn)
  {
    m_connections[iConn] = new Connection();
  }

  m_listenCommandsSocket = new NMP::SocketWrapper();
  m_listenDataSocket = new NMP::SocketWrapper();
  m_listenFileServerSocket = new NMP::SocketWrapper();

  m_tempCommandsSocket = new NMP::SocketWrapper();
  m_tempDataSocket = new NMP::SocketWrapper();
  m_tempFileServerSocket = new NMP::SocketWrapper();

  if (initListenSocket(m_listenCommandsSocket, listenPort))
  {
    if (initListenSocket(m_listenDataSocket, listenPort + 1))
    {
      if (initListenSocket(m_listenFileServerSocket, listenPort + 2))
      {
        m_initialized = true;
        return ConnectionManager::kNoError;
      }
    }
  }

  // Something went wrong. Clean up.
  destroy();
  return ConnectionManager::kSocketError;
}

//----------------------------------------------------------------------------------------------------------------------
ConnectionManager::ConnectionManager() :
  m_numConnections(0),
  m_listenCommandsSocket(0),
  m_listenDataSocket(0),
  m_listenFileServerSocket(0),
  m_initialized(false)
{

}

//----------------------------------------------------------------------------------------------------------------------
void ConnectionManager::destroy()
{
  // Then delete the connection object.
  m_numConnections = 0;
  for (uint32_t iConn = 0; iConn < MAX_NUMBER_CONNECTIONS; ++iConn)
  {
    delete m_connections[iConn];
  }

  delete m_tempCommandsSocket;
  delete m_tempDataSocket;
  delete m_tempFileServerSocket;

  m_commandsBuffer.term();
}

//----------------------------------------------------------------------------------------------------------------------
void ConnectionManager::term()
{
  // First terminate active connections.
  for (uint32_t iConn = 0; iConn < getNumConnections(); ++iConn)
  {
    m_connections[iConn]->terminate();
  }

  NMP::shutdown(m_listenCommandsSocket->getSocket(), 0x02);
  NMP::closesocket(m_listenCommandsSocket->getSocket());
  delete m_listenCommandsSocket;

  NMP::shutdown(m_listenDataSocket->getSocket(), 0x02);
  NMP::closesocket(m_listenDataSocket->getSocket());
  delete m_listenDataSocket;

  NMP::shutdown(m_listenFileServerSocket->getSocket(), 0x02);
  NMP::closesocket(m_listenFileServerSocket->getSocket());
  delete m_listenFileServerSocket;

  destroy();

  m_initialized = false;
}

//----------------------------------------------------------------------------------------------------------------------
void ConnectionManager::removeConnection(Connection* connection)
{
  // Find the connection
  uint32_t foundIndex = (uint32_t) - 1;
  for (uint32_t i = 0; i < m_numConnections; ++i)
  {
    if (connection == m_connections[i])
    {
      foundIndex = i;
      break;
    }
  }

  if (foundIndex != (uint32_t) - 1)
  {
    removeConnection(foundIndex);
  }
}

//----------------------------------------------------------------------------------------------------------------------
void ConnectionManager::removeConnection(uint32_t connIndex)
{
  NMP_ASSERT(connIndex < m_numConnections);

  // Remember if the connection to be removed is master.
  bool wasMaster = m_connections[connIndex]->isMaster();

  m_connections[connIndex]->terminate();
  Connection* temp = m_connections[connIndex];
  for (uint32_t i = connIndex; i < m_numConnections - 1; ++i)
  {
    m_connections[i] = m_connections[i+1];
  }

  --m_numConnections;
  m_connections[m_numConnections] = temp;

  // If the removed connection wasn't master, there's no need to make any change.
  // If it was, there's no master anymore, so make the first one (if it existes) master.
  if (getNumConnections() >= 1 && wasMaster)
  {
    m_connections[0]->setMaster(true);
  }
}

//----------------------------------------------------------------------------------------------------------------------
Connection* ConnectionManager::addConnection(
  NMP::SocketWrapper& commandsSocketWrapper,
  NMP::SocketWrapper& dataSocketWrapper,
  NMP::SocketWrapper& fileServerSocketWrapper)
{
  NMP_ASSERT(m_numConnections < MAX_NUMBER_CONNECTIONS);

  Connection* connection = m_connections[m_numConnections];
  connection->initialize(
    commandsSocketWrapper,
    dataSocketWrapper,
    fileServerSocketWrapper);

  ++m_numConnections;

  if (m_numConnections == 1)
  {
    // If this is the only connection, it must be the master.
    connection->setMaster(true);
  }

  return connection;
}

//----------------------------------------------------------------------------------------------------------------------
bool ConnectionManager::broadcastPacket(PacketBase& pkt)
{
  for (uint32_t iConn = 0; iConn < getNumConnections(); ++iConn)
  {
    Connection* connection = getConnection(iConn);
    connection->bufferDataPacket(pkt);
  }

  return true;
}

//----------------------------------------------------------------------------------------------------------------------
void ConnectionManager::flushDataBuffers()
{
  for (uint32_t iConn = 0; iConn < getNumConnections(); ++iConn)
  {
    getConnection(iConn)->flushDataBuffer();
  }
}

} // namespace MCOMMS

//----------------------------------------------------------------------------------------------------------------------
#ifdef NM_COMPILER_MSVC
  #pragma warning (pop)
#endif
//----------------------------------------------------------------------------------------------------------------------
